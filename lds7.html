<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>LDS Museum — Celestial Gallery (VR)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0e1624" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&family=Inter:wght@300;500;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --txt:#f6fbff; --muted:#bbd0e6;
      --glass:rgba(8,14,26,0.35); --glass-bd:rgba(255,255,255,0.14);
      --brand:#cfe7ff; --accent:#cfe7ff;  /* UI only */
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; color:var(--txt);
      background:
        radial-gradient(1400px 900px at 60% -10%, rgba(140,190,255,0.16) 0%, transparent 55%),
        linear-gradient(180deg,#0b1324 0%, #0c1220 60%, #0a111b 100%);
      font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      overflow:hidden;
    }
    #scene-wrap{position:fixed; inset:0}
    canvas{touch-action:none}

    .panel{
      position:fixed; right:16px; top:16px; z-index:5;
      background:var(--glass); backdrop-filter: blur(10px);
      border:1px solid var(--glass-bd); border-radius:14px; padding:12px 14px; min-width:220px;
      box-shadow:0 6px 30px rgba(0,0,0,0.45);
    }
    .panel h3{font:700 14px Orbitron,Inter,sans-serif; letter-spacing:1.5px; margin:0 0 8px; color:var(--brand)}
    .row{display:flex; gap:10px; align-items:center; margin:8px 0}
    .btn{
      appearance:none; border:1px solid var(--glass-bd); background:rgba(255,255,255,0.06);
      color:var(--txt); border-radius:12px; font:600 13px Inter,system-ui; padding:8px 12px; cursor:pointer;
    }
    .hint{font-size:12px; color:var(--muted); margin-top:4px}
    .title{
      position:fixed; left:50%; top:24px; transform:translateX(-50%);
      font:700 16px Orbitron,Inter,sans-serif; letter-spacing:2px; text-transform:uppercase;
      color:var(--muted); opacity:0.9; z-index:4; display:none;
    }
    @media (min-width:860px){ .title{display:block;} }

    /* ===== Loader Overlay ===== */
    .loader{
      position:fixed; inset:0; z-index:9999;
      background: linear-gradient(180deg, #0b1324 0%, #0c1220 60%);
      display:flex; align-items:center; justify-content:center;
    }
    .loader .wrap{
      width:min(560px, 92vw); border-radius:16px; padding:18px;
      background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.18);
      box-shadow:0 10px 40px rgba(0,0,0,0.55); backdrop-filter: blur(10px);
    }
    .loader h1{margin:0 0 10px; font:700 16px Orbitron,Inter,sans-serif; letter-spacing:1.8px; color:var(--brand); text-transform:uppercase}
    .loader p{margin:6px 0; color:var(--muted); font-size:13px; line-height:1.4}
    .bar{height:10px; width:100%; border-radius:999px; background:rgba(255,255,255,0.08); overflow:hidden; border:1px solid rgba(255,255,255,0.18)}
    .bar > i{display:block; height:100%; width:0%; background:linear-gradient(90deg, #a3c9ff, #e5f0ff); border-radius:999px; transition:width .18s ease}
    .stats{display:flex; gap:10px; align-items:center; justify-content:space-between; margin-top:8px}
    .pct{font:700 14px Inter,system-ui}
    .eta{font:600 12px Inter,system-ui; color:#cfe7ff}
    .disclaimer{
      margin-top:10px; padding:10px; border-radius:10px;
      background:rgba(255,255,255,0.06); border:1px dashed rgba(255,255,255,0.2); color:#ebf4ff; font-size:12px; line-height:1.45;
    }
    .loader.fade{animation:fadeOut .6s ease forwards}
    @keyframes fadeOut{to{opacity:0; visibility:hidden}}
  </style>
</head>
<body>
  <div id="scene-wrap"></div>
  <div class="title">LDS Museum — Celestial Gallery</div>

  <div class="panel" id="panel">
    <h3>VR</h3>
    <div class="row"><button class="btn" id="vrBtn">Enter VR</button></div>
    <div class="hint">WebXR works in Chrome/Edge (Android) and Quest Browser.</div>
  </div>

  <!-- Loading Overlay -->
  <div class="loader" id="loader">
    <div class="wrap">
      <h1>Preparing HD Scene…</h1>
      <div class="bar"><i id="barFill"></i></div>
      <div class="stats">
        <div class="pct"><span id="pct">0</span>% • <span id="stepLabel">Initializing…</span></div>
        <div class="eta">ETA: <span id="eta">--:--</span></div>
      </div>
      <p id="subStatus">Stars, auroras, and alabaster artifacts.</p>
      <div class="disclaimer">
        Personal, independent project for educational/demo purposes.
        Not affiliated with <b>The Church of Jesus Christ of Latter-day Saints</b>.
      </div>
    </div>
  </div>

  <script type="module">
    import * as THREE from '/three3.js';
    import { OrbitControls } from '/orbit.js';

    const IS_MOBILE = /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i.test(navigator.userAgent) || (window.matchMedia && matchMedia('(pointer:coarse)').matches);

    // ===== Loader state =====
    const loaderEl   = document.getElementById('loader');
    const barFillEl  = document.getElementById('barFill');
    const pctEl      = document.getElementById('pct');
    const etaEl      = document.getElementById('eta');
    const stepLabel  = document.getElementById('stepLabel');
    const subStatus  = document.getElementById('subStatus');

    const steps = [];
    let done = 0;
    const startTime = performance.now();
    function updateProgress(label){
      const total = steps.length || 1;
      const frac = Math.min(1, done / total);
      const pct  = Math.round(frac * 100);
      barFillEl.style.width = pct + '%';
      pctEl.textContent = pct;
      if (label) stepLabel.textContent = label;
      const elapsed = (performance.now() - startTime) / 1000;
      const remain  = (frac > 0.01) ? Math.max(0, elapsed * (1/frac - 1)) : NaN;
      etaEl.textContent = isFinite(remain) ? `${Math.floor(remain/60)}:${Math.floor(remain%60).toString().padStart(2,'0')}` : '--:--';
    }
    async function runStep(label, fn){
      updateProgress(label);
      await new Promise(r => requestAnimationFrame(r));
      await fn();
      done++; updateProgress(label);
      await new Promise(r => requestAnimationFrame(r));
    }
    function enqueue(label, fn){ steps.push({label, fn}); }

    // ===== Core THREE setup (HD) =====
    let scene, camera, renderer, controls, floor;
    const raycaster = new THREE.Raycaster(), pointer = new THREE.Vector2();

    const wrap = document.getElementById('scene-wrap');
    renderer = new THREE.WebGLRenderer({ antialias: !IS_MOBILE, alpha: true, powerPreference: 'high-performance' });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(IS_MOBILE ? Math.min(devicePixelRatio, 1.75) : Math.min(devicePixelRatio, 2.5));
    renderer.shadowMap.enabled = !IS_MOBILE;
    if (!IS_MOBILE && THREE.PCFSoftShadowMap) renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    // HD color pipeline
    if ('ACESFilmicToneMapping' in THREE) renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.0;
    if ('outputColorSpace' in renderer) renderer.outputColorSpace = THREE.SRGBColorSpace;
    else if ('outputEncoding' in renderer) renderer.outputEncoding = THREE.sRGBEncoding;

    wrap.appendChild(renderer.domElement);
    renderer.domElement.style.touchAction = 'none';
    renderer.xr.enabled = true;

    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0a111b, IS_MOBILE ? 0.025 : 0.018);

    camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 320);
    camera.position.set(0, 1.6, 1.2);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.06;
    controls.enablePan = true; controls.screenSpacePanning = true;
    controls.rotateSpeed = 0.9; controls.zoomSpeed = 0.85; controls.panSpeed = 0.65;
    controls.minDistance = 1.2; controls.maxDistance = 80.0; controls.maxPolarAngle = Math.PI * 0.49;
    controls.target.set(0, 1.3, 0);
    if ('zoomToCursor' in controls) controls.zoomToCursor = true;
    if (controls.touches) { // make sure 2-finger = pan on mobile
      controls.touches.ONE = THREE.TOUCH.ROTATE;
      controls.touches.TWO = THREE.TOUCH.PAN;
      controls.touches.THREE = THREE.TOUCH.DOLLY;
    }

    const xrRig = new THREE.Group(); scene.add(xrRig); xrRig.add(camera);

    renderer.xr.addEventListener('sessionstart', ()=>{ controls.enabled = false; });
    renderer.xr.addEventListener('sessionend',   ()=>{ controls.enabled = true;  });

    addEventListener('resize', () => {
      camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // ===== Atmosphere & lights =====
    enqueue('Atmosphere & lights', async ()=>{
      // Neutral lights (no green cast)
      scene.add(new THREE.AmbientLight(0xEEF2F8, 0.25));
      const hemi = new THREE.HemisphereLight(0xDDE7FF, 0x0a111b, 0.7); scene.add(hemi);
      const key = new THREE.DirectionalLight(0xFFF7E0, 0.46);
      key.position.set(-8, 12, 10); key.castShadow = !IS_MOBILE;
      key.shadow.mapSize.set(1024,1024); key.shadow.camera.far = 70; scene.add(key);
      const fill = new THREE.PointLight(0xF3F7FF, 0.3, 90, 2.0); fill.position.set(0, 10, 0); scene.add(fill);

      // Starfield
      const starCount = IS_MOBILE ? 900 : 2200;
      const starGeo = new THREE.BufferGeometry();
      const positions = new Float32Array(starCount * 3);
      for (let i=0;i<starCount;i++){
        const r = 90 + Math.random()*90;
        const theta = Math.random()*Math.PI*2;
        const phi = Math.acos(THREE.MathUtils.randFloatSpread(2));
        positions[i*3+0] = r*Math.sin(phi)*Math.cos(theta);
        positions[i*3+1] = r*Math.cos(phi);
        positions[i*3+2] = r*Math.sin(phi)*Math.sin(theta);
      }
      starGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      const starMat = new THREE.PointsMaterial({ size: IS_MOBILE?0.5:0.7, sizeAttenuation:true, color:0xBFD6FF, transparent:true, opacity:0.9, depthWrite:false });
      scene.add(new THREE.Points(starGeo, starMat));

      // Skydome
      const skyGeo = new THREE.SphereGeometry(160, 60, 40);
      const skyMat = new THREE.ShaderMaterial({
        side: THREE.BackSide, transparent:true, depthWrite:false,
        uniforms: { top:{value:new THREE.Color(0x0b1730)}, mid:{value:new THREE.Color(0x0d1932)}, bot:{value:new THREE.Color(0x0a111b)} },
        vertexShader: `varying vec3 vPos; void main(){ vPos=position; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
        fragmentShader: `
          varying vec3 vPos; uniform vec3 top,mid,bot;
          void main(){
            float h = clamp((vPos.y+160.0)/160.0, 0.0, 1.0);
            vec3 col = mix(bot, mix(mid, top, smoothstep(0.2,0.9,h)), smoothstep(0.0,1.0,h));
            gl_FragColor = vec4(col, 1.0);
          }
        `
      });
      scene.add(new THREE.Mesh(skyGeo, skyMat));

      // ==== HD Aurora (green ribbons), even higher detail ====
      function auroraRibbon(opts={}){
        const {
          radius=78, height=24, width=13, y=13, rotY=0.0,
          hue=0x58ffc0, hue2=0xb8ffe8, edge=0x6bfacc,
          opacity=0.8, phase=0.0, speed=0.33,
          detail=IS_MOBILE?160:384
        } = opts;

        const geo = new THREE.PlaneGeometry(radius, height, detail, 80);
        const mat = new THREE.ShaderMaterial({
          transparent:true, blending:THREE.AdditiveBlending, depthWrite:false,
          uniforms:{
            time:{value:0},
            hueA:{value:new THREE.Color(hue)}, hueB:{value:new THREE.Color(hue2)}, edgeC:{value:new THREE.Color(edge)},
            opacity:{value:opacity}, phase:{value:phase}, speed:{value:speed}, width:{value:width}
          },
          vertexShader: `
            uniform float time, phase, speed, width;
            varying vec2 vUv; varying vec3 vPos;
            void main(){
              vUv = uv;
              vec3 pos = position;

              float ang = (uv.x - 0.5) * 1.95;
              float rad = ${radius.toFixed(1)} * 0.5;
              pos.x = sin(ang) * rad;
              pos.z = -cos(ang) * rad;

              float w1 = sin( (uv.x*12.0 + phase) + time*speed )*0.9;
              float w2 = sin( (uv.x*3.7  - phase*0.6) - time*speed*0.6 )*0.7;
              float w3 = sin( (uv.x*20.0 + phase*1.7) + time*speed*1.6 )*0.25;
              pos.y += w1 + w2 + w3;
              pos.y += (uv.y-0.5) * width;

              pos.xz *= mat2(cos(0.12*pos.y), -sin(0.12*pos.y), sin(0.12*pos.y), cos(0.12*pos.y));
              vPos = pos;
              gl_Position = projectionMatrix * modelViewMatrix * vec4(pos,1.0);
            }
          `,
          fragmentShader: `
            uniform vec3 hueA, hueB, edgeC; uniform float opacity;
            varying vec2 vUv;

            float hash(vec2 p){ return fract(sin(dot(p, vec2(41.0,289.0))) * 45758.5453); }
            float noise(vec2 p){
              vec2 i=floor(p), f=fract(p);
              float a=hash(i), b=hash(i+vec2(1,0)), c=hash(i+vec2(0,1)), d=hash(i+vec2(1,1));
              vec2 u=f*f*(3.0-2.0*f);
              return mix(a,b,u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y;
            }
            float fbm(vec2 p){
              float v=0.0, a=0.5;
              for(int i=0;i<7;i++){ v+=a*noise(p); p*=2.0; a*=0.5; }
              return v;
            }
            float dither(vec2 p){ return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453); }

            void main(){
              float edgeY = smoothstep(0.02, 0.18, vUv.y) * (1.0 - smoothstep(0.82, 0.98, vUv.y));
              float edgeX = smoothstep(0.00, 0.06, vUv.x) * (1.0 - smoothstep(0.94, 1.0, vUv.x));
              float mask = edgeY * edgeX;

              float n = fbm(vUv*vec2(11.0,2.6));
              float glow = smoothstep(0.35, 1.0, n);

              vec3 col = mix(hueA, hueB, vUv.y*0.7 + glow*0.3);
              col = mix(col, edgeC, pow(vUv.y, 3.0)*0.25);

              float a = mask * (0.45 + 0.55*glow) * opacity;
              a = clamp(a + (dither(vUv*1200.0)-0.5)*0.02, 0.0, 1.0);

              gl_FragColor = vec4(col, a);
            }
          `
        });
        const mesh = new THREE.Mesh(geo, mat);
        mesh.position.y = y; mesh.rotation.y = rotY;
        return mesh;
      }

      const aurGroup = new THREE.Group();
      const A1 = auroraRibbon({ radius:86, height:26, width:14, y:14, rotY: Math.PI*0.04,  phase:0.0,  speed:0.32 });
      const A2 = auroraRibbon({ radius:78, height:22, width:12, y:12, rotY:-Math.PI*0.33, phase:1.7,  speed:0.27 });
      const A3 = auroraRibbon({ radius:92, height:28, width:15, y:15, rotY: Math.PI*0.52,  phase:3.3,  speed:0.30, opacity:0.72 });
      aurGroup.add(A1,A2,A3);
      scene.add(aurGroup);

      // Soft cloud floor
      const cloudGeo = new THREE.CircleGeometry(34, 120);
      const cloudMat = new THREE.ShaderMaterial({
        transparent:true, depthWrite:false,
        uniforms:{ time:{value:0}, color:{value:new THREE.Color(0xffffff)}, alpha:{value:0.9} },
        vertexShader: `varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
        fragmentShader: `
          varying vec2 vUv; uniform float time; uniform vec3 color; uniform float alpha;
          float hash(vec2 p){ return fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453); }
          float noise(vec2 p){ vec2 i=floor(p), f=fract(p);
            float a=hash(i), b=hash(i+vec2(1,0)), c=hash(i+vec2(0,1)), d=hash(i+vec2(1,1));
            vec2 u=f*f*(3.0-2.0*f); return mix(a,b,u.x) + (c-a)*u.y*(1.0-u.x) + (d-b)*u.x*u.y; }
          float fbm(vec2 p){ float v=0.0, a=0.5; for(int i=0;i<6;i++){ v+=a*noise(p); p*=2.0; a*=0.5; } return v; }
          void main(){
            vec2 uv=vUv*2.0-1.0;
            float r=length(uv);
            float ring=smoothstep(1.15, 0.45, r);
            float layers = 0.7 + 0.3*fbm(uv*3.0 + time*0.02);
            float a = clamp(ring*layers, 0.0, 1.0) * alpha * 0.45;
            gl_FragColor=vec4(color, a);
          }
        `
      });
      const clouds = new THREE.Mesh(cloudGeo, cloudMat);
      clouds.rotation.x = -Math.PI/2; clouds.position.y = 0.01;
      scene.add(clouds);

      // updater
      const updaters = [];
      updaters.push((t)=>{
        cloudMat.uniforms.time.value = t;
        A1.material.uniforms.time.value = t;
        A2.material.uniforms.time.value = t;
        A3.material.uniforms.time.value = t;
        aurGroup.rotation.y = Math.sin(t*0.05)*0.08;
      });
      scene.userData._tickAtmos = (t)=> updaters.forEach(fn=>fn(t));
    });

    // ===== Teleport floor (invisible) =====
    enqueue('Floor', async ()=>{
      floor = new THREE.Mesh(new THREE.CircleGeometry(50, 72),
        new THREE.MeshBasicMaterial({ color:0x000000, opacity:0.0, transparent:true }));
      floor.rotation.x = -Math.PI/2; floor.position.y = 0;
      scene.add(floor);
    });

    // ===== White artifact helpers =====
    function makeGlowPad(radius=1.5, strength=0.55, color=0xFFFFFF){
      const g = new THREE.RingGeometry(radius*0.55, radius, 80);
      const m = new THREE.MeshBasicMaterial({ color, transparent:true, opacity:strength, side:THREE.DoubleSide });
      const ring = new THREE.Mesh(g, m);
      ring.rotation.x = -Math.PI/2;
      return ring;
    }
    function makeLabel(text) {
      const c = document.createElement('canvas'), p=16, fs=30;
      const ctx = c.getContext('2d');
      ctx.font = `700 ${fs}px Inter, Arial`;
      const w = Math.ceil(ctx.measureText(text).width) + p*2; const h = fs + p*2;
      c.width = w; c.height = h; const g = c.getContext('2d'); g.font = `700 ${fs}px Inter, Arial`;
      g.fillStyle='rgba(8,14,26,0.66)'; g.strokeStyle='rgba(255,255,255,0.18)'; g.lineWidth=3;
      g.beginPath(); const r=14; g.moveTo(r,0); g.arcTo(w,0,w,h,r); g.arcTo(w,h,0,h,r); g.arcTo(0,h,0,0,r); g.arcTo(0,0,w,0,r); g.closePath();
      g.fill(); g.stroke();
      g.fillStyle='#ffffff'; g.textAlign='center'; g.textBaseline='middle'; g.fillText(text,w/2,h/2);
      const tex = new THREE.CanvasTexture(c); tex.minFilter = THREE.LinearFilter;
      const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent:true, depthWrite:false, depthTest:true }));
      const s=0.007; spr.scale.set(w*s, h*s, 1); return spr;
    }
    function makeSub(text){
      const c = document.createElement('canvas'), p=10, fs=18; const ctx = c.getContext('2d');
      ctx.font = `600 ${fs}px Inter, Arial`; const w = Math.ceil(ctx.measureText(text).width) + p*2; const h = fs + p*2; c.width = w; c.height = h;
      const g = c.getContext('2d'); g.font = `600 ${fs}px Inter, Arial`; g.fillStyle='rgba(255,255,255,0.92)'; g.textAlign='center'; g.textBaseline='middle'; g.fillText(text,w/2,h/2);
      const tex = new THREE.CanvasTexture(c); tex.minFilter = THREE.LinearFilter;
      const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent:true, depthWrite:false })); const s=0.006; spr.scale.set(w*s, h*s, 1); return spr;
    }
    function makePedestal({wTop=0.9,wBot=1.0,h=0.7}={}){
      const grp = new THREE.Group();
      const marble = new THREE.MeshStandardMaterial({ color:0xF2F3F6, roughness:0.9, metalness:0.03, emissive:0x111111, emissiveIntensity:0.04 });
      const base  = new THREE.Mesh(new THREE.CylinderGeometry(wBot*0.85,wBot*0.85,0.08,28), marble);
      const core  = new THREE.Mesh(new THREE.CylinderGeometry(wTop*0.85,wTop*0.85, h*0.55,28), marble);
      const cap   = new THREE.Mesh(new THREE.CylinderGeometry(wTop*0.82, wTop*0.82,0.05,28), marble);
      base.position.y = 0.04; core.position.y = h*0.275+0.08; cap.position.y = h*0.55+0.12;
      [base,core,cap].forEach(m=>{ m.receiveShadow = !IS_MOBILE; m.castShadow = !IS_MOBILE; });
      const glow = makeGlowPad(1.55, 0.5, 0xFFFFFF); glow.position.y = 0.005;
      grp.add(glow, base, core, cap); grp.userData.topY = cap.position.y+0.04;
      return grp;
    }
    function addExhibit({ name, sub, pos = {x:0,y:0,z:0}, buildMesh, spotlight=true, link } = {}) {
      const group = new THREE.Group();
      group.position.set(pos.x||0, pos.y||0, pos.z||0);

      const dir = new THREE.Vector3().subVectors(new THREE.Vector3(0,1.2,0), group.position).normalize();
      const lookAt = new THREE.Object3D(); lookAt.position.copy(dir).add(group.position); group.lookAt(lookAt.position);

      const pedestal = makePedestal(); group.add(pedestal);
      const builder = (typeof buildMesh === 'function') ? buildMesh : ()=> new THREE.Group();
      let mesh = builder(); if (!mesh || !(mesh && mesh.isObject3D)) mesh = new THREE.Group();
      mesh.position.y = pedestal.userData.topY || 0.95;
      if (mesh.castShadow !== undefined){ mesh.castShadow = !IS_MOBILE; mesh.receiveShadow = !IS_MOBILE; }
      group.add(mesh);

      const label = makeLabel(name); label.position.set(0, (pedestal.userData.topY||1.0)+0.85, 0); group.add(label);
      if (sub){ const l2 = makeSub(sub); l2.position.set(0, (pedestal.userData.topY||1.0)+0.55, 0); group.add(l2); }
      if (!IS_MOBILE && spotlight){
        const spot = new THREE.SpotLight(0xFFFFFF, 0.6, 9, Math.PI/8, 0.35, 1.4);
        spot.position.set(group.position.x+0.8, 4.6, group.position.z+0.8);
        spot.target = mesh; spot.castShadow = true; group.add(spot, spot.target);
      }
      if(link) group.userData.link = link;
      scene.add(group);
      return group;
    }

    // ===== UNIVERSAL WHITE MATERIALS (no green) =====
    const whiteStone  = ()=> new THREE.MeshStandardMaterial({ color:0xF1F3F7, metalness:0.05, roughness:0.92 });
    const whiteMetal  = ()=> new THREE.MeshStandardMaterial({ color:0xF5F7FA, metalness:0.25, roughness:0.35 });
    const whitePorc   = ()=> new THREE.MeshStandardMaterial({ color:0xFFFFFF, metalness:0.02, roughness:0.6 });

    // ===== Exhibit builders (all white/pearl) =====
    function buildTemple(){
      const g = new THREE.Group(); const mat = whiteStone();
      const nave = new THREE.Mesh(new THREE.BoxGeometry(1.9, 1.2, 0.85), mat); nave.position.y = 0.6; g.add(nave);
      const towerGeo = new THREE.BoxGeometry(0.34, 2.0, 0.34);
      const T = [new THREE.Mesh(towerGeo, mat),new THREE.Mesh(towerGeo, mat),new THREE.Mesh(towerGeo, mat),new THREE.Mesh(towerGeo, mat)];
      T[0].position.set(-0.68, 1.0,  0.26); T[1].position.set(0.68, 1.0,  0.26);
      T[2].position.set(-0.68, 1.0, -0.26); T[3].position.set(0.68, 1.0, -0.26); g.add(...T);
      const center = new THREE.Mesh(new THREE.BoxGeometry(0.46, 2.3, 0.46), mat); center.position.set(0, 1.15, 0); g.add(center);
      function spire(h=0.48){ return new THREE.Mesh(new THREE.ConeGeometry(0.14, h, 14), mat); }
      const s = [spire(), spire(), spire(), spire(), new THREE.Mesh(new THREE.ConeGeometry(0.18,0.7,14), mat)];
      s[0].position.copy(T[0].position).setY(2.05); s[1].position.copy(T[1].position).setY(2.05);
      s[2].position.copy(T[2].position).setY(2.05); s[3].position.copy(T[3].position).setY(2.05);
      s[4].position.set(0, 2.75, 0); g.add(...s);
      // subtle halo (white)
      const halo = new THREE.Mesh(new THREE.RingGeometry(0.28, 0.4, 40), new THREE.MeshBasicMaterial({ color:0xFFFFFF, transparent:true, opacity:0.45, side:THREE.DoubleSide }));
      halo.rotation.x = Math.PI/2; halo.position.set(0, 2.68, 0); g.add(halo);
      g.userData.update = ()=>{ g.rotation.y += 0.016; halo.rotation.z += 0.01; };
      return g;
    }
    function buildMoroni(){ // white stylized
      const g = new THREE.Group(); const mat = whitePorc();
      const robe = new THREE.Mesh(new THREE.ConeGeometry(0.14, 0.8, 16), mat); robe.position.y = 0.4;
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.09, 18, 16), mat); head.position.y = 0.84;
      const arm  = new THREE.Mesh(new THREE.CylinderGeometry(0.024, 0.024, 0.4, 16), mat); arm.position.set(0.14, 0.72, 0); arm.rotation.z = -Math.PI/6;
      const trumpet = new THREE.Mesh(new THREE.CylinderGeometry(0.006, 0.03, 0.52, 14), whiteMetal()); trumpet.rotation.x = -Math.PI/4; trumpet.position.set(0.22, 0.88, 0.08);
      g.add(robe, head, arm, trumpet);
      g.userData.update = ()=>{ g.rotation.y += 0.07; }; return g;
    }
    function buildPlates(){
      const g = new THREE.Group(); const wm = whiteMetal();
      const plates = new THREE.Mesh(new THREE.BoxGeometry(0.32, 0.1, 0.24), wm); plates.position.y = 0.05; g.add(plates);
      const ringGeo = new THREE.TorusGeometry(0.075, 0.01, 12, 20);
      for (let i=0;i<3;i++){ const r = new THREE.Mesh(ringGeo, wm); r.rotation.x = Math.PI/2; r.position.set(-0.14, 0.075, -0.07 + i*0.07); g.add(r); }
      g.userData.update = ()=>{ plates.rotation.y += 0.05; }; return g;
    }
    function buildBook(){
      const g = new THREE.Group();
      const coverMat = whitePorc();
      const sideMat  = whiteStone();
      const geo = new THREE.BoxGeometry(0.28, 0.05, 0.19);
      const mats = [sideMat, sideMat, sideMat, sideMat, coverMat, sideMat];
      const book  = new THREE.Mesh(geo, mats); book.position.y = 0.025; g.add(book);
      g.userData.update = ()=>{ book.rotation.y += 0.04; }; return g;
    }
    function buildLiahona(){
      const g = new THREE.Group();
      const shell = new THREE.Mesh(new THREE.SphereGeometry(0.22, 24, 20), new THREE.MeshPhysicalMaterial({
        color:0xFFFFFF, metalness:0.1, roughness:0.1, transmission:0.75, thickness:0.24, ior:1.2, clearcoat:1.0, clearcoatRoughness:0.18
      })); g.add(shell);
      const ptrGrp = new THREE.Group();
      const rod = new THREE.Mesh(new THREE.CylinderGeometry(0.012,0.012,0.42,14), whiteMetal());
      rod.rotation.z = Math.PI/2; const rod2 = rod.clone(); rod2.rotation.x = Math.PI/2; ptrGrp.add(rod, rod2); g.add(ptrGrp);
      g.userData.update = ()=>{ ptrGrp.rotation.y += 0.5; }; return g;
    }
    function buildTree(){
      const g = new THREE.Group();
      const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.14, 1.02, 12), whiteStone()); trunk.position.y = 0.51; g.add(trunk);
      const canopyMat = new THREE.MeshStandardMaterial({ color:0xFFFFFF, emissive:0xFFFFFF, emissiveIntensity:0.2, roughness:0.4 });
      [[0,1.04,0],[0.22,0.92,0],[-0.22,0.92,0],[0,0.9,0.22],[0,0.9,-0.22]].forEach(p=>{
        const s=new THREE.Mesh(new THREE.SphereGeometry(0.22, 18, 16), canopyMat); s.position.set(...p); g.add(s);
      });
      return g;
    }
    function buildIronRod(){
      const g = new THREE.Group();
      const railMat = whiteMetal();
      const base = new THREE.Mesh(new THREE.BoxGeometry(1.02, 0.02, 0.28), whiteStone()); base.position.y = 0.01; g.add(base);
      for (let i=0;i<6;i++){ const post = new THREE.Mesh(new THREE.CylinderGeometry(0.017,0.017,0.56,14), railMat); post.position.set(-0.47+i*0.188, 0.28, 0); g.add(post); }
      const rail = new THREE.Mesh(new THREE.CylinderGeometry(0.023,0.023,1.02,18), railMat); rail.rotation.z = Math.PI/2; rail.position.y = 0.56; g.add(rail);
      return g;
    }
    function buildFirstVision(){
      const g = new THREE.Group();
      const ground = new THREE.Mesh(new THREE.CylinderGeometry(0.68,0.68,0.04,28), whiteStone()); ground.position.y = 0.02; g.add(ground);
      function tree(x,z){ const t=new THREE.Group();
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.035,0.058,0.56,12), whiteStone()); trunk.position.y=0.28; t.add(trunk);
        const crown = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 14), whitePorc()); crown.position.y=0.58; t.add(crown);
        t.position.set(x,0,z); return t; }
      g.add(tree(-0.29,-0.12), tree(0.29,0.10), tree(0.05,-0.29));
      const cone = new THREE.Mesh(new THREE.ConeGeometry(0.4, 0.8, 20), new THREE.MeshBasicMaterial({ color:0xFFFFFF, transparent:true, opacity:0.2 })); cone.position.y = 0.74; cone.rotation.x = Math.PI; g.add(cone);
      const spot = new THREE.SpotLight(0xFFFFFF, 0.85, 2.4, Math.PI/6, 0.4, 1.6); spot.position.set(0, 1.4, 0.0); spot.target = ground; g.add(spot, spot.target);
      return g;
    }
    function buildTablets(){
      const g = new THREE.Group(); const mat = whiteStone();
      function tablet(){ const w=0.36, h=0.48, r=0.18; const shape = new THREE.Shape();
        shape.moveTo(-w/2,0); shape.lineTo(-w/2,h-r); shape.absarc(0,h-r,r,Math.PI,0,false); shape.lineTo(w/2,0); shape.lineTo(-w/2,0);
        return new THREE.Mesh(new THREE.ExtrudeGeometry(shape,{ depth:0.044, bevelEnabled:false }), mat); }
      const A = tablet(), B = tablet(); A.rotation.y = Math.PI + 0.08; B.rotation.y = Math.PI - 0.08; A.position.x = -0.2; B.position.x = 0.2; A.position.y = B.position.y = 0.24; g.add(A,B);
      return g;
    }
    function buildBeehive(){
      const g = new THREE.Group(); const mat = whiteStone();
      const rings = [0.30,0.26,0.22,0.18].map((R,i)=>{ const t=new THREE.Mesh(new THREE.TorusGeometry(R, 0.044-(i*0.006), 14, 28), mat); t.position.y = 0.095 + i*0.11; return t; });
      rings.forEach(r=>g.add(r));
      const cap = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 14), mat); cap.position.y = 0.58; g.add(cap);
      const hole = new THREE.Mesh(new THREE.CylinderGeometry(0.032,0.032,0.012,12), new THREE.MeshStandardMaterial({ color:0x111111 })); hole.rotation.x = Math.PI/2; hole.position.set(0, 0.14, -0.28);
      g.add(hole); return g;
    }
    function buildJoseph(){
      const g = new THREE.Group(); const stone = whiteStone();
      const base = new THREE.Mesh(new THREE.CylinderGeometry(0.26,0.29,0.12,22), stone); base.position.y = 0.06; g.add(base);
      const robe = new THREE.Mesh(new THREE.ConeGeometry(0.22, 0.88, 20), stone); robe.position.y = 0.55; g.add(robe);
      const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.14,0.26,16), stone); torso.position.y = 0.88; g.add(torso);
      const head  = new THREE.Mesh(new THREE.SphereGeometry(0.10, 20, 18), stone); head.position.y = 1.12; g.add(head);
      const arm   = new THREE.Mesh(new THREE.CylinderGeometry(0.034,0.034,0.32,16), stone); arm.position.set(0.20, 1.0, 0); arm.rotation.z = -Math.PI/4; g.add(arm);
      const book = new THREE.Mesh(new THREE.BoxGeometry(0.14,0.024,0.09), whitePorc());
      book.position.set(0.31, 1.1, 0.04); g.add(book);
      g.userData.update = (t)=>{ head.rotation.y = Math.sin(t*0.5)*0.1; };
      return g;
    }

    // ===== Place exhibits in a circle, face center =====
    let exTemple, exMoroni, exPlates, exBook, exLiah, exTree, exRod, exFirst, exTabs, exBee, exJoseph;
    const EXHIBIT_RADIUS = 12.5;
    const BASE_SCALE = 1.25;
    const exhibits = [
      { key:'temple',  name:'Salt Lake Temple', sub:'Symbolic Model', build:buildTemple,  link:'temple.html',   scale:BASE_SCALE*1.6 },
      { key:'moroni',  name:'Angel Moroni',     sub:'Trumpeting Angel', build:buildMoroni, link:'moroni.html',   scale:BASE_SCALE*1.05 },
      { key:'plates',  name:'Golden Plates',    sub:'Source of Translation', build:buildPlates, link:'plates.html', scale:BASE_SCALE*1.05 },
      { key:'book',    name:'Book of Mormon',   sub:'Sacred Record', build:buildBook, link:'bookofmormon.html', scale:BASE_SCALE*1.05 },
      { key:'liah',    name:'Liahona',          sub:'Divine Compass', build:buildLiahona, link:'liahona.html',   scale:BASE_SCALE*1.05 },
      { key:'tree',    name:'Tree of Life',     sub:'Lehi’s Vision', build:buildTree, link:'treeoflife.html',   scale:BASE_SCALE*1.15 },
      { key:'rod',     name:'Iron Rod',         sub:'Hold Fast to the Path', build:buildIronRod, link:'ironrod.html', scale:BASE_SCALE*1.05 },
      { key:'first',   name:'The First Vision', sub:'Sacred Grove', build:buildFirstVision, link:'firstvision.html', scale:BASE_SCALE*1.05 },
      { key:'tabs',    name:'Ten Commandments', sub:'Tablets of Law', build:buildTablets, link:'tencommandments.html', scale:BASE_SCALE*1.05 },
      { key:'bee',     name:'Beehive',          sub:'Industry & Unity', build:buildBeehive, link:'beehive.html', scale:BASE_SCALE*1.05 },
      { key:'joseph',  name:'Joseph Smith',     sub:'Statue (Stylized)', build:buildJoseph, link:'josephsmith.html', scale:BASE_SCALE*1.1 },
    ];
    enqueue('Placing exhibits', async ()=>{
      const angleStep = 2 * Math.PI / exhibits.length;
      exhibits.forEach((e, idx)=>{
        const pos = { x: Math.sin(idx*angleStep)*EXHIBIT_RADIUS, y:0, z: -Math.cos(idx*angleStep)*EXHIBIT_RADIUS };
        const ex = addExhibit({ name:e.name, sub:e.sub, pos, buildMesh:e.build, link:e.link });
        const s = e.scale || BASE_SCALE; ex.scale.setScalar(s);
        switch(e.key){
          case 'temple': exTemple=ex; break; case 'moroni': exMoroni=ex; break; case 'plates': exPlates=ex; break;
          case 'book': exBook=ex; break; case 'liah': exLiah=ex; break; case 'tree': exTree=ex; break; case 'rod': exRod=ex; break;
          case 'first': exFirst=ex; break; case 'tabs': exTabs=ex; break; case 'bee': exBee=ex; break; case 'joseph': exJoseph=ex; break;
        }
      });

      // Start at center but looking at the Temple
      if (exTemple){
        const p = exTemple.getWorldPosition(new THREE.Vector3());
        controls.target.copy(p);
        const dir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
        camera.position.copy(p).addScaledVector(dir, 6.0);
      }
    });

    // ===== VR helpers & interaction (double = focus, triple = open link) =====
    let controller, controllerRay, reticle;
    enqueue('VR & interactions', async ()=>{
      controller = renderer.xr.getController(0); xrRig.add(controller);
      const controllerGeo = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1) ]);
      controllerRay = new THREE.Line(controllerGeo, new THREE.LineBasicMaterial({ transparent:true, opacity:0.8 }));
      controllerRay.name = 'controllerRay'; controllerRay.scale.z = 10; controller.add(controllerRay);
      reticle = new THREE.Mesh(new THREE.RingGeometry(0.15, 0.17, 32), new THREE.MeshBasicMaterial({ transparent:true, opacity:0.85, side:THREE.DoubleSide }));
      reticle.rotation.x = -Math.PI/2; reticle.visible = false; scene.add(reticle);

      const tempMatrix = new THREE.Matrix4();
      function intersectController(ctrl, objects){
        tempMatrix.identity().extractRotation(ctrl.matrixWorld);
        raycaster.ray.origin.setFromMatrixPosition(ctrl.matrixWorld);
        raycaster.ray.direction.set(0,0,-1).applyMatrix4(tempMatrix);
        const hits = raycaster.intersectObjects(objects, true);
        return hits[0] || null;
      }
      function tryTeleport(){
        if (!renderer.xr.isPresenting) return;
        const hit = intersectController(controller, [floor]);
        if (hit){ xrRig.position.set(hit.point.x, 0, hit.point.z); }
      }
      controller.addEventListener('select', tryTeleport);

      function setPointer(e){
        const rect = renderer.domElement.getBoundingClientRect();
        const cx = e.touches ? e.touches[0].clientX : e.clientX;
        const cy = e.touches ? e.touches[0].clientY : e.clientY;
        pointer.x = ((cx - rect.left) / rect.width) * 2 - 1; pointer.y = -((cy - rect.top) / rect.height) * 2 + 1;
      }
      function getHitAtPointer(e){
        setPointer(e); raycaster.setFromCamera(pointer, camera);
        const objs = [exTemple, exMoroni, exPlates, exBook, exLiah, exTree, exRod, exFirst, exTabs, exBee, exJoseph, floor];
        return raycaster.intersectObjects(objs, true)[0] || null;
      }
      function smoothFocus(targetPoint){
        const p = targetPoint.clone();
        const dist = camera.position.distanceTo(controls.target);
        const dir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
        const newCamPos = new THREE.Vector3().copy(p).addScaledVector(dir, Math.max(3.0, Math.min(18.0, dist)));
        const start = performance.now(); const fromCam = camera.position.clone(); const fromTgt = controls.target.clone();
        const ease = t => 1 - Math.pow(1 - t, 3);
        (function step(now){ const t = Math.min(1, (now - start) / 460); const e2 = ease(t); camera.position.lerpVectors(fromCam, newCamPos, e2); controls.target.lerpVectors(fromTgt, p, e2); if (t < 1) requestAnimationFrame(step); })(start);
      }

      // Mouse: Double = focus, Triple = open link
      let clickCount = 0, lastClickTime = 0, lastClickX = 0, lastClickY = 0, clickTimer;
      renderer.domElement.addEventListener('click', (e) => {
        const now = performance.now();
        const dx = e.clientX - lastClickX;
        const dy = e.clientY - lastClickY;
        if (now - lastClickTime < 320 && (dx*dx+dy*dy) < (24*24)) clickCount++; else clickCount = 1;
        lastClickTime = now; lastClickX = e.clientX; lastClickY = e.clientY;

        clearTimeout(clickTimer);
        clickTimer = setTimeout(() => {
          const hit = getHitAtPointer(e);
          if (clickCount === 2 && hit){
            let obj = hit.object; while (obj && !obj.userData.link && obj.parent) obj = obj.parent;
            const point = obj ? obj.getWorldPosition(new THREE.Vector3()) : hit.point;
            smoothFocus(point);
          } else if (clickCount >= 3 && hit){
            let obj = hit.object; while (obj && !obj.userData.link && obj.parent) obj = obj.parent;
            if (obj && obj.userData.link) window.location.href = obj.userData.link;
          }
          clickCount = 0;
        }, 340);
      }, false);

      // Touch: Double tap = focus, Triple tap = open link
      let tapCount = 0, lastTapTime = 0, lastTapX = 0, lastTapY = 0, tapTimer;
      renderer.domElement.addEventListener('touchend', (e) => {
        if (!e.changedTouches || e.changedTouches.length !== 1) return;
        const touch = e.changedTouches[0];
        const now = performance.now();
        const dx = touch.clientX - lastTapX; const dy = touch.clientY - lastTapY;
        if (now - lastTapTime < 320 && (dx*dx+dy*dy) < (24*24)) tapCount++; else tapCount = 1;
        lastTapTime = now; lastTapX = touch.clientX; lastTapY = touch.clientY;

        clearTimeout(tapTimer);
        tapTimer = setTimeout(() => {
          const fakeEvt = { touches:[touch], clientX: touch.clientX, clientY: touch.clientY };
          const hit = getHitAtPointer(fakeEvt);
          if (tapCount === 2 && hit){
            let obj = hit.object; while (obj && !obj.userData.link && obj.parent) obj = obj.parent;
            const point = obj ? obj.getWorldPosition(new THREE.Vector3()) : hit.point;
            smoothFocus(point);
          } else if (tapCount >= 3 && hit){
            let obj = hit.object; while (obj && !obj.userData.link && obj.parent) obj = obj.parent;
            if (obj && obj.userData.link) window.location.href = obj.userData.link;
          }
          tapCount = 0;
        }, 360);
      }, { passive:true });

      controller._intersectForReticle = () => {
        const tm = new THREE.Matrix4();
        tm.identity().extractRotation(controller.matrixWorld);
        raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
        raycaster.ray.direction.set(0,0,-1).applyMatrix4(tm);
        const hit = raycaster.intersectObjects([floor], true)[0];
        if (renderer.xr.isPresenting && hit){ reticle.position.copy(hit.point); reticle.visible = true; } else { reticle.visible = false; }
      };
    });

    // ===== Warmup / render loop =====
    enqueue('Finalizing', async ()=>{
      renderer.render(scene, camera);
      subStatus.textContent = 'Almost there… preparing first frame.';
    });

    const clock = new THREE.Clock();
    function renderLoop(){
      controls.update();
      const t = clock.getElapsedTime();
      if (scene.userData._tickAtmos) scene.userData._tickAtmos(t);

      [exTemple, exMoroni, exPlates, exBook, exLiah, exTree, exRod, exFirst, exTabs, exBee, exJoseph].forEach(g=>{
        if (!g) return;
        const upd = g.children.find(o=>o.userData && o.userData.update);
        if (upd && upd.userData.update) upd.userData.update(t);
        if (g.userData.update) g.userData.update(t);
      });

      if (controller && controller._intersectForReticle) controller._intersectForReticle();
      renderer.render(scene, camera);
    }
    renderer.setAnimationLoop(renderLoop);

    // ===== Run steps =====
    (async ()=>{
      for (const s of steps){ await runStep(s.label, s.fn); }
      updateProgress('Ready');
      subStatus.textContent = 'Loaded. Welcome to the Celestial Gallery.';
      setTimeout(()=>{ loaderEl.classList.add('fade'); }, 250);
    })();

    // ===== VR button =====
    const vrBtn = document.getElementById('vrBtn');
    let currentSession = null;
    if (vrBtn){
      vrBtn.addEventListener('click', async ()=>{
        if (!('xr' in navigator)){
          alert('WebXR not supported on this device/browser. Try Chrome on Android or the Quest Browser.');
          return;
        }
        if (!currentSession){
          try {
            const session = await navigator.xr.requestSession('immersive-vr', { requiredFeatures: ['local-floor'] });
            currentSession = session;
            session.addEventListener('end', ()=>{ currentSession = null; vrBtn.textContent = 'Enter VR'; });
            await renderer.xr.setSession(session);
            vrBtn.textContent = 'Exit VR';
          } catch (e) {
            console.warn('VR start failed:', e);
            alert('Unable to start VR: ' + (e?.message ?? e));
          }
        } else { currentSession.end(); }
      });
    }
  </script>
</body>
</html>
