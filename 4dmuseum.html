<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>4D Museum — Hypercube Gallery</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0b0f22" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&family=Inter:wght@300;500;700&display=swap" rel="stylesheet">
  <style>
    :root { --bg:#0b0f22; --bg-2:#0a0d1b; --txt:#e6ebff; --muted:#9aa4c7; --glass:rgba(255,255,255,0.06); --glass-bd:rgba(255,255,255,0.12); }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:radial-gradient(1200px 800px at 70% -10%, #18204b 0%, var(--bg) 60%), var(--bg-2);
      color:var(--txt);
      font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      overflow:hidden
    }
    #scene-wrap{position:fixed;inset:0}
    canvas{touch-action:none}
  </style>
</head>
<body>
  <div id="scene-wrap"></div>

  <script type="module">
    import * as THREE from '/three3.js';
    import { OrbitControls } from '/orbit.js';

    // --- Mobile detection for lighter path
    const IS_MOBILE =
      /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i.test(navigator.userAgent) ||
      (window.matchMedia && matchMedia("(pointer:coarse)").matches);

    // Core
    let scene, camera, renderer, controls, floor;
    const raycaster = new THREE.Raycaster();
    const pointer   = new THREE.Vector2();

    // Renderer
    const wrap = document.getElementById('scene-wrap');
    renderer = new THREE.WebGLRenderer({ antialias: !IS_MOBILE, alpha: true, powerPreference: "high-performance" });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(IS_MOBILE ? Math.min(devicePixelRatio, 1.5) : Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = !IS_MOBILE;
    if (!IS_MOBILE && THREE.PCFSoftShadowMap) renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    wrap.appendChild(renderer.domElement);
    renderer.domElement.style.touchAction = 'none';

    // Scene + camera + controls
    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x060814, 24, 180);

    camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 400);
    camera.position.set(0, 1.6, 12);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.enablePan = true;
    controls.screenSpacePanning = true;
    controls.rotateSpeed = 0.9;
    controls.zoomSpeed   = 0.8;
    controls.panSpeed    = 0.6;
    controls.minDistance = 1.2;
    controls.maxDistance = 80.0;
    controls.maxPolarAngle = Math.PI * 0.49;
    controls.target.set(0, 1.3, -6);
    if ('zoomToCursor' in controls) controls.zoomToCursor = true;

    addEventListener('resize', () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // Lights (same museum feel)
    scene.add(new THREE.AmbientLight(0xffffff, 0.24));

    const key = new THREE.DirectionalLight(0xbfd7ff, 0.75);
    key.position.set(6, 10, 6);
    key.castShadow = !IS_MOBILE;
    key.shadow.mapSize.set(1024, 1024);
    scene.add(key);

    const hemi = new THREE.HemisphereLight(0xbfd7ff, 0x0b0f26, IS_MOBILE ? 0.6 : 0.35);
    scene.add(hemi);

    const fill = new THREE.PointLight(0x8ea6ff, 0.55, 60, 1.5);
    fill.position.set(-4, 4, -2);
    scene.add(fill);

    // Room
    const room = new THREE.Mesh(
      new THREE.BoxGeometry(22, 8, 100),
      new THREE.MeshStandardMaterial({ color:0x0f1330, roughness:0.9, metalness:0.05, side:THREE.BackSide })
    );
    scene.add(room);

    floor = new THREE.Mesh(
      new THREE.PlaneGeometry(40, 160),
      new THREE.MeshStandardMaterial({ color:0x0b0f26, roughness:0.2, metalness:0.4 })
    );
    floor.rotation.x = -Math.PI/2;
    floor.receiveShadow = !IS_MOBILE;
    scene.add(floor);

    // Starfield
    const starGeo = new THREE.BufferGeometry();
    const starCount = IS_MOBILE ? 600 : 1200;
    const starPos = new Float32Array(starCount*3);
    for (let i=0;i<starCount;i++){
      starPos[i*3+0] = (Math.random()-0.5)*120;
      starPos[i*3+1] = (Math.random()*40)+2;
      starPos[i*3+2] = -10 - Math.random()*200;
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPos,3));
    const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ size:0.26, color:0xbcd3ff, transparent:true, opacity:0.85 }));
    scene.add(stars);

    // Label helper (same style)
    function makeLabel(text) {
      const c = document.createElement('canvas'), p=16, fs=34;
      const ctx = c.getContext('2d');
      ctx.font = `bold ${fs}px Inter, Arial`;
      const w = Math.ceil(ctx.measureText(text).width) + p*2;
      const h = fs + p*2;
      c.width = w; c.height = h;
      const c2 = c.getContext('2d');
      c2.font = `bold ${fs}px Inter, Arial`;
      c2.fillStyle='rgba(20,26,56,0.85)'; c2.strokeStyle='rgba(255,255,255,0.2)'; c2.lineWidth=4;
      c2.beginPath(); const r=18;
      c2.moveTo(r,0); c2.arcTo(w,0,w,h,r); c2.arcTo(w,h,0,h,r); c2.arcTo(0,h,0,0,r); c2.arcTo(0,0,w,0,r); c2.closePath();
      c2.fill(); c2.stroke();
      c2.fillStyle='#e6ebff'; c2.textAlign='center'; c2.textBaseline='middle';
      c2.fillText(text,w/2,h/2);
      const tex = new THREE.CanvasTexture(c);
      tex.minFilter = THREE.LinearFilter;
      const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent:true, depthWrite:false }));
      const s=0.008; spr.scale.set(w*s, h*s, 1); return spr;
    }

    // Pedestal maker
    function makePedestal(){
      const p = new THREE.Mesh(
        new THREE.CylinderGeometry(0.65, 0.75, 0.5, 32),
        new THREE.MeshStandardMaterial({ color:0x121731, metalness:0.2, roughness:0.45 })
      );
      p.receiveShadow = !IS_MOBILE;
      return p;
    }

    // --- Exhibit builder
    function addExhibit({ name, pos, buildMesh }) {
      const group = new THREE.Group();
      group.position.set(pos.x, pos.y, pos.z);

      const pedestal = makePedestal();
      group.add(pedestal);

      const mesh = buildMesh();
      mesh.position.y = 0.95;
      if (mesh.castShadow !== undefined) mesh.castShadow = !IS_MOBILE;
      group.add(mesh);

      const label = makeLabel(name);
      label.position.set(0, 2.0, 0);
      group.add(label);

      // subtle exhibit spot (desktop only)
      if (!IS_MOBILE) {
        const spot = new THREE.SpotLight(0xffffff, 0.9, 10, Math.PI/6, 0.35, 1.8);
        spot.position.set(0.8, 3.5, 0.8);
        spot.target = mesh;
        group.add(spot, spot.target);
      }

      scene.add(group);
      return group;
    }

    // --- 4D Hypercube (Tesseract) simulation
    function buildTesseract(){
      // 16 vertices (±1, ±1, ±1, ±1)
      const verts4 = [];
      for (let i=0;i<16;i++){
        verts4.push([
          (i & 1) ? 1 : -1,             // x
          (i & 2) ? 1 : -1,             // y
          (i & 4) ? 1 : -1,             // z
          (i & 8) ? 1 : -1              // w
        ]);
      }
      // edges: differ by exactly one bit (Hamming distance 1) => 32 edges
      const edges = [];
      for (let i=0;i<16;i++){
        for (let j=i+1;j<16;j++){
          const d = ((i^j).toString(2).match(/1/g)||[]).length;
          if (d===1) edges.push([i,j]);
        }
      }

      // Buffer for line segments
      const pos = new Float32Array(edges.length * 2 * 3);
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(pos,3));
      const mat = new THREE.LineBasicMaterial({ color:0x9db3ff });
      const lines = new THREE.LineSegments(geo, mat);

      // Projection helper (4D → 3D)
      const v4 = { x:0, y:0, z:0, w:0 };
      function rot4(v, a, b, theta){ // rotate in plane (a,b) of [x,y,z,w]
        const s = Math.sin(theta), c = Math.cos(theta);
        const va = v[a], vb = v[b];
        v[a] = va * c - vb * s;
        v[b] = va * s + vb * c;
      }
      function project4to3(v, d=3.6){ // perspective by w; adjust d for depth
        const f = 1 / (d - v.w);
        return [ v.x * f, v.y * f, v.z * f ];
      }

      // Animation: spin in XW, YW, ZW planes
      lines.userData.update = (time)=>{
        let idx = 0;
        // pre-rotate all vertices
        const rotated = new Array(16);
        for (let i=0;i<16;i++){
          v4.x = verts4[i][0];
          v4.y = verts4[i][1];
          v4.z = verts4[i][2];
          v4.w = verts4[i][3];
          rot4(v4, 'x','w', time*0.6);
          rot4(v4, 'y','w', time*0.47);
          rot4(v4, 'z','w', time*0.38);
          const p3 = project4to3(v4, 3.4);
          rotated[i] = p3;
        }
        for (let e=0;e<edges.length;e++){
          const a = rotated[edges[e][0]];
          const b = rotated[edges[e][1]];
          pos[idx++] = a[0]; pos[idx++] = a[1]; pos[idx++] = a[2];
          pos[idx++] = b[0]; pos[idx++] = b[1]; pos[idx++] = b[2];
        }
        geo.attributes.position.needsUpdate = true;
      };

      // scale to fit pedestal nicely
      lines.scale.setScalar(0.9);
      return lines;
    }

    // --- Minimal complement exhibits (2): Möbius & Spectral Prism
    function buildMobius(){
      const g = new THREE.BufferGeometry();
      const segments = 180, width = 0.22;
      const positions = [];
      for (let i=0;i<=segments;i++){
        const t = i / segments * Math.PI*2;
        const ct = Math.cos(t), st = Math.sin(t);
        const nx = Math.cos(t/2), ny = Math.sin(t/2);
        const cx = Math.cos(t),   cy = 0, cz = Math.sin(t);
        // two edge points per segment (ribbon)
        positions.push(cx + width*nx, cy + width*ny, cz);
        positions.push(cx - width*nx, cy - width*ny, cz);
      }
      const idx = [];
      for (let i=0;i<segments;i++){
        const a = i*2, b=a+1, c=a+2, d=a+3;
        idx.push(a,b,c, b,d,c);
      }
      g.setAttribute('position', new THREE.Float32BufferAttribute(positions,3));
      g.setIndex(idx);
      g.computeVertexNormals();
      const m = new THREE.MeshStandardMaterial({ color:0x9aaeff, metalness:0.6, roughness:0.3, side:THREE.DoubleSide });
      const mesh = new THREE.Mesh(g,m);
      mesh.rotation.x = Math.PI/2;
      return mesh;
    }

    function buildPrism(){
      return new THREE.Mesh(
        new THREE.CylinderGeometry(0.55, 0.55, 1.0, 3),
        new THREE.MeshStandardMaterial({ color:0x9fd0ff, metalness:0.2, roughness:0.1, transparent:true, opacity:0.75 })
      );
    }

    // Place exhibits (just 3 total)
    const ex1 = addExhibit({ name:'Hypercube (4D)',   pos:{x:-3.2,y:0,z:-10}, buildMesh:buildTesseract });
    const ex2 = addExhibit({ name:'Möbius Ribbon',    pos:{x: 0.0,y:0,z:-16}, buildMesh:buildMobius    })

    // --- Refocus at pointer (dblclick / double-tap)
    function setPointer(e){
      const rect = renderer.domElement.getBoundingClientRect();
      const cx = e.touches ? e.touches[0].clientX : e.clientX;
      const cy = e.touches ? e.touches[0].clientY : e.clientY;
      pointer.x = ((cx - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((cy - rect.top) / rect.height) * 2 + 1;
    }
    function focusAtPointer(e){
      setPointer(e);
      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects([ex1, ex2, floor], true);
      if (!hits.length) return;
      const p = hits[0].point;
      const dist = camera.position.distanceTo(controls.target);
      const dir  = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
      const newCamPos = new THREE.Vector3().copy(p).addScaledVector(dir, dist);

      const start = performance.now();
      const fromCam = camera.position.clone();
      const fromTgt = controls.target.clone();
      const ease = t => 1 - Math.pow(1 - t, 3);
      (function step(now){
        const t = Math.min(1, (now - start) / 420);
        const e2 = ease(t);
        camera.position.lerpVectors(fromCam, newCamPos, e2);
        controls.target.lerpVectors(fromTgt, p, e2);
        if (t < 1) requestAnimationFrame(step);
      })(start);
    }
    renderer.domElement.addEventListener('dblclick', focusAtPointer, { passive:true });

    // mobile double-tap to refocus
    let lastTapTime = 0, lastTapX=0, lastTapY=0;
    renderer.domElement.addEventListener('touchend', (e)=>{
      if (!e.changedTouches || e.changedTouches.length!==1) return;
      const touch = e.changedTouches[0];
      const now = performance.now();
      const dt = now - lastTapTime;
      const dx = touch.clientX - lastTapX;
      const dy = touch.clientY - lastTapY;
      lastTapTime = now; lastTapX = touch.clientX; lastTapY = touch.clientY;
      if (dt < 320 && (dx*dx+dy*dy) < (24*24)) focusAtPointer({ touches:[touch] });
    }, { passive:true });

    // Animate
    const clock = new THREE.Clock();
    function animate(){
      const t = clock.getElapsedTime();
      controls.update();

      // keep target reasonable
      const tgt = controls.target;
      tgt.x = Math.max(-6, Math.min(6, tgt.x));
      tgt.y = Math.max(0.5, Math.min(3.5, tgt.y));
      tgt.z = Math.max(-120, Math.min(-4, tgt.z));

      // update tesseract wireframe
      const lines = ex1.children.find(o => o.isLineSegments);
      if (lines && lines.userData.update) lines.userData.update(t);

      // gentle ambient motion
      ex2.rotation.y += 0.25 * clock.getDelta();
      stars.rotation.y += 0.02 * clock.getDelta();

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>
