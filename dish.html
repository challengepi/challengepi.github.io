<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Headquarter — Cosmic Waves Museum (OBJ, Even Lighting)</title>
  <style>
    html, body { margin: 0; height: 100%; background: #0b0f22; overflow: hidden; }
    canvas { touch-action: none; }

    /* Loading overlay */
    #overlay {
      position: fixed; inset: 0;
      display: grid; place-items: center;
      background:
        radial-gradient(1200px 800px at 70% -10%, rgba(24,32,75,.55) 0%, rgba(11,15,34,.85) 60%),
        rgba(10,13,27,0.9);
      color: #e6ebff; font: 500 14px system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      z-index: 10; transition: opacity .35s ease;
    }
    #overlay.hide { opacity: 0; pointer-events: none; }
    .panel {
      display: grid; gap: 10px; justify-items: center;
      padding: 16px 22px; border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06); backdrop-filter: blur(8px);
      box-shadow: 0 10px 30px rgba(63,90,255,.18) inset, 0 6px 18px rgba(0,0,0,.25);
    }
    .spinner {
      width: 34px; height: 34px; border-radius: 50%;
      border: 3px solid rgba(255,255,255,0.2);
      border-top-color: #a7b8ff;
      animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .label { color:#cfd8ff; font-weight:600; letter-spacing:.3px }
    .muted { color:#9aa4c7; font-weight:500 }
  </style>

  <!-- Import map to your ES module build of three -->
  <script type="importmap">
  {
    "imports": {
      "three": "./three.module.js"
    }
  }
  </script>
</head>
<body>
  <!-- Loading overlay -->
  <div id="overlay">
    <div class="panel">
      <div class="spinner"></div>
      <div id="label" class="label">Loading…</div>
      <div class="muted"><span id="progress">0</span>%</div>
    </div>
  </div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "./orbit.js";
    import { MTLLoader } from "./MTLLoader.js";
    import { OBJLoader } from "./OBJLoader.js";

    // -------- Renderer --------
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, powerPreference: "high-performance" });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.NoToneMapping;   // linear brightness
    renderer.toneMappingExposure = 1.0;
    renderer.shadowMap.enabled = false;           // even lighting: no shadows
    document.body.appendChild(renderer.domElement);

    // -------- Scene / Camera / Controls --------
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0f22);

    const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 800);
    camera.position.set(0, 2.2, 10);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.maxPolarAngle = Math.PI * 0.49;
    controls.minDistance = 3;
    controls.maxDistance = 40;
    controls.target.set(0, 1.6, 0);

    addEventListener("resize", () => {
      camera.aspect = innerWidth / innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // -------- Museum-ish Environment (visual only) --------
    scene.add(new THREE.Mesh(
      new THREE.BoxGeometry(28, 10, 48),
      new THREE.MeshStandardMaterial({ color: 0x0f1330, roughness: 0.9, metalness: 0.05, side: THREE.BackSide })
    ));

    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(60, 90),
      new THREE.MeshStandardMaterial({ color: 0x0b0f26, roughness: 0.2, metalness: 0.4 })
    );
    floor.rotation.x = -Math.PI / 2;
    scene.add(floor);

    // -------- Even, sunlight-like lighting (uniform, no shadows) --------
    scene.add(new THREE.AmbientLight(0xffffff, 1.0));
    scene.add(new THREE.HemisphereLight(0xffffff, 0xffffff, 0.9));
    [
      [ 1, 1,  0],
      [-1, 1,  0],
      [ 0, 1,  1],
      [ 0, 1, -1],
    ].forEach(([x,y,z]) => {
      const d = new THREE.DirectionalLight(0xffffff, 0.6);
      d.position.set(x*10, y*10, z*10);
      scene.add(d);
    });

    // -------- Loading overlay hooks --------
    const overlay = document.getElementById("overlay");
    const labelEl = document.getElementById("label");
    const progressEl = document.getElementById("progress");
    function hideOverlay() {
      overlay.classList.add("hide");
      setTimeout(()=> overlay.remove(), 400);
    }
    function setPercent(p) {
      progressEl.textContent = Math.max(0, Math.min(100, Math.round(p)));
    }

    // -------- Load Model (OBJ + optional MTL) --------
    const manager = new THREE.LoadingManager();
    manager.onStart = () => { labelEl.textContent = "Loading…"; setPercent(0); };
    manager.onProgress = (_url, loaded, total) => {
      // Manager counts files; we show coarse progress here.
      if (total > 0) setPercent((loaded / total) * 100);
    };
    manager.onError = (url) => { labelEl.textContent = "Error loading: " + url; };

    const mtlLoader = new MTLLoader(manager);
    const objLoader = new OBJLoader(manager);
    mtlLoader.setResourcePath("./");

    function setSRGB(mat) {
      if (!mat) return;
      if (mat.map) mat.map.colorSpace = THREE.SRGBColorSpace;
      if (mat.emissiveMap) mat.emissiveMap.colorSpace = THREE.SRGBColorSpace;
    }

    function fitAndPlace(obj) {
      obj.updateMatrixWorld(true);

      // Scale and floor
      const box = new THREE.Box3().setFromObject(obj);
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z) || 1;
      obj.scale.setScalar(6.0 / maxDim);

      obj.updateMatrixWorld(true);
      const box2 = new THREE.Box3().setFromObject(obj);
      const ctr  = box2.getCenter(new THREE.Vector3());
      obj.position.x += -ctr.x;
      obj.position.z += -ctr.z;
      obj.position.y += -box2.min.y + 0.0;

      // Light-friendly materials & normals
      obj.traverse((n) => {
        if (!n.isMesh) return;

        if (n.geometry && (!n.geometry.attributes || !n.geometry.attributes.normal)) {
          n.geometry.computeVertexNormals();
        }

        if (n.material) n.material.side = THREE.DoubleSide;

        const src = n.material || {};
        const isStd = src.isMeshStandardMaterial === true;
        const isTooDark = src.color && src.color.isColor &&
                          src.color.r < 0.02 && src.color.g < 0.02 && src.color.b < 0.02;

        if (!isStd || isTooDark) {
          const lit = new THREE.MeshStandardMaterial({
            color: isTooDark ? new THREE.Color(0xdddddd) : (src.color ? src.color.clone() : new THREE.Color(0xdddddd)),
            map: src.map || null,
            normalMap: src.normalMap || null,
            metalness: 0.15,
            roughness: 0.5,
            transparent: src.transparent ?? (src.opacity < 1),
            opacity: src.opacity ?? 1
          });
          setSRGB(lit);
          n.material = lit;
        } else {
          setSRGB(n.material);
        }
      });

      scene.add(obj);

      const framed = new THREE.Box3().setFromObject(obj).getSize(new THREE.Vector3());
      controls.target.set(0, Math.max(1.2, framed.y * 0.45), 0);
      camera.position.set(0, Math.max(1.6, framed.y * 0.55), framed.z * 1.4 + 6);

      // Model is in — hide loader
      hideOverlay();
    }

    // Fine-grained network progress (bytes) for OBJ
    function onXHRProgress(xhr){
      if (xhr && xhr.lengthComputable) {
        setPercent((xhr.loaded / xhr.total) * 100);
        labelEl.textContent = "Loading model…";
      }
    }

    // Try MTL first; fallback to OBJ only
    mtlLoader.load(
      "dish.mtl",
      (materials) => {
        materials.preload();
        Object.values(materials.materials || {}).forEach(setSRGB);
        objLoader.setMaterials(materials);
        objLoader.setPath("./");
        objLoader.load("dish.obj", (obj) => fitAndPlace(obj), onXHRProgress, (e)=>{ labelEl.textContent = "Failed to load OBJ"; console.error(e); });
      },
      () => { /* onProgress for MTL omitted */ },
      () => {
        // No MTL — just OBJ
        objLoader.setPath("./");
        objLoader.load("dish.obj", (obj) => fitAndPlace(obj), onXHRProgress, (e)=>{ labelEl.textContent = "Failed to load OBJ"; console.error(e); });
      }
    );

    // -------- Animate --------
    (function animate(){
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    })();
  </script>
</body>
</html>
