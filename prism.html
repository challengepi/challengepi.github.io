<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Spectral Prism — Cosmic Waves Museum</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0b0f22" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&family=Inter:wght@300;500;700&display=swap" rel="stylesheet">
  <style>
    :root { --bg:#0b0f22; --bg-2:#0a0d1b; --txt:#e6ebff; --muted:#9aa4c7; }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:radial-gradient(1200px 800px at 70% -10%, #18204b 0%, var(--bg) 60%), var(--bg-2);color:var(--txt);
         font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;overflow:hidden}
    #scene-wrap{position:fixed;inset:0}
    canvas{touch-action:none}
    /* No HUD / UI — pure 3D */
  </style>
</head>
<body>
  <div id="scene-wrap"></div>
  <script type="module">
    import { OrbitControls } from '/orbit.js';
    import * as THREE from '/three3.js';

    const IS_MOBILE = /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i.test(navigator.userAgent) || (window.matchMedia && matchMedia('(pointer:coarse)').matches);

    // renderer
    const wrap = document.getElementById('scene-wrap');
    const renderer = new THREE.WebGLRenderer({ antialias: !IS_MOBILE, alpha: true, powerPreference: 'high-performance' });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(IS_MOBILE ? Math.min(devicePixelRatio, 1.5) : Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = !IS_MOBILE;
    wrap.appendChild(renderer.domElement);

    // scene
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x060814, 24, 180);

    // camera & controls
    const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 400);
    camera.position.set(0, 1.6, 8);
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.06; controls.maxPolarAngle = Math.PI*0.49;
    controls.target.set(0,1.1,0);

    addEventListener('resize', ()=>{ camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

    // Minimal environment (no extra lights)
    const room = new THREE.Mesh(new THREE.BoxGeometry(22, 8, 28), new THREE.MeshStandardMaterial({ color:0x0f1330, roughness:0.9, metalness:0.05, side:THREE.BackSide }));
    scene.add(room);
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(40, 40), new THREE.MeshStandardMaterial({ color:0x0b0f26, roughness:0.2, metalness:0.4 }));
    floor.rotation.x = -Math.PI/2; floor.receiveShadow = !IS_MOBILE; scene.add(floor);

    // Starfield ambiance (unlit; does not count as a light source)
    const starGeo = new THREE.BufferGeometry();
    const starCount = IS_MOBILE?600:1200; const starPos = new Float32Array(starCount*3);
    for(let i=0;i<starCount;i++){ starPos[i*3+0]=(Math.random()-0.5)*120; starPos[i*3+1]=(Math.random()*40)+2; starPos[i*3+2]=-10 - Math.random()*80; }
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPos,3));
    const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ size:0.26, color:0xbcd3ff, transparent:true, opacity:0.85 }));
    scene.add(stars);

    // --- Prism + single light source only ---
    const group = new THREE.Group(); scene.add(group);

    // Glass prism
    const prism = new THREE.Mesh(
      new THREE.CylinderGeometry(0.9, 0.9, 2.2, 3, 1, false),
      new THREE.MeshPhysicalMaterial({ color:0x99bbff, metalness:0.0, roughness:0.08, transmission:0.92, thickness:0.8, ior:1.52, transparent:true, opacity:1.0, clearcoat:0.25, clearcoatRoughness:0.2 })
    );
    prism.rotation.z = Math.PI/2; // lay it on its side
    prism.position.set(0, 1.1, 0);
    prism.castShadow = !IS_MOBILE; prism.receiveShadow = !IS_MOBILE;
    group.add(prism);

    // Visible emitter sphere (represents the ONLY light source)
    const emitter = new THREE.Mesh(new THREE.SphereGeometry(0.1, 24, 24), new THREE.MeshStandardMaterial({ color:0xffffff, emissive:0xffffff, emissiveIntensity:1.0 }));
    emitter.position.set(-3.4, 1.1, 0);
    group.add(emitter);

    // Point light co-located with emitter (single light source)
    const light = new THREE.PointLight(0xffffff, 3.2, 18, 2.0);
    light.position.copy(emitter.position);
    light.castShadow = !IS_MOBILE;
    scene.add(light);

    // Optional simple visual beam from emitter to prism for clarity (unlit geometry, not a light)
    const beamLen = 3.2;
    const beam = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, beamLen, 8), new THREE.MeshBasicMaterial({ color:0xffffff, transparent:true, opacity:0.85 }));
    beam.rotation.z = Math.PI/2; beam.position.set(-1.8, 1.1, 0);
    group.add(beam);

    // Animation
    let spinning = true;
    const clock = new THREE.Clock();
    function animate(){
      const dt = clock.getDelta();
      controls.update();
      stars.rotation.y += 0.02*dt;
      if (spinning) prism.rotation.y += 0.12*dt;
      renderer.render(scene,camera);
      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>
