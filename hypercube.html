<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>4D Tesseract Visualization</title>
  <style>
    body { margin:0; overflow:hidden; background:#111; }
    #canvas { width:100%; height:100%; display:block; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <script type="module">
        import { OrbitControls } from '/orbit.js';
    import * as THREE from '/three3.js';
    
    // Set up renderer, camera, and scene
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x111111);
    
    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 5);
    const controls = new OrbitControls(camera, renderer.domElement);
    
    // Define 4D hypercube vertices (all combinations of Â±1 in 4 dimensions)
    const verts4D = [];
    for (let i=0; i<16; i++) {
      const x = (i & 1) ? 1 : -1;
      const y = (i & 2) ? 1 : -1;
      const z = (i & 4) ? 1 : -1;
      const w = (i & 8) ? 1 : -1;
      verts4D.push(new THREE.Vector4(x, y, z, w));
    }
    // Compute edges: pairs of vertex indices that differ in exactly one bit
    const edges = [];
    for (let i = 0; i < 16; i++) {
      for (let d = 0; d < 4; d++) {
        const j = i ^ (1<<d);
        if (j > i) edges.push([i, j]);
      }
    }
    
    // Create a BufferGeometry to hold line segments for edges
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(edges.length * 2 * 3);
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    const material = new THREE.LineBasicMaterial({ color: 0xffffff });
    const lineSegments = new THREE.LineSegments(geometry, material);
    scene.add(lineSegments);
    
    // 4D rotation parameters
    let angle = 0;
    
    function animate() {
      requestAnimationFrame(animate);
      angle += 0.01;
      
      // Rotate all 4D vertices around the X-W plane (for example)
      const cos = Math.cos(angle), sin = Math.sin(angle);
      verts4D.forEach(v => {
        const x = v.x * cos - v.w * sin;
        const w = v.x * sin + v.w * cos;
        v.x = x; v.w = w;
      });
      
      // Project 4D points to 3D and update line segment positions
      const cam4D = 4; // distance of "4D camera"
      const posAttr = geometry.attributes.position;
      edges.forEach((edge, idx) => {
        const [i, j] = edge;
        [i, j].forEach((vi, k) => {
          const v = verts4D[vi];
          // Perspective divide: scale factor from 4D to 3D
          const scale = cam4D / (cam4D - v.w);
          const px = v.x * scale;
          const py = v.y * scale;
          const pz = v.z * scale;
          // Each edge contributes two points
          const base = 3 * (2*idx + k);
          posAttr.array[base]   = px;
          posAttr.array[base+1] = py;
          posAttr.array[base+2] = pz;
        });
      });
      posAttr.needsUpdate = true;
      
      controls.update();
      renderer.render(scene, camera);
    }
    
    animate();
    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight);
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
