<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>LDS Museum — Gallery (VR)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#120a0a" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&family=Inter:wght@300;500;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0f0f12; --bg-2:#0a0a0c; --txt:#fffaf2; --muted:#d8c9c0; --glass:rgba(255,255,255,0.08); --glass-bd:rgba(255,255,255,0.18);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; color:var(--txt);
      background:
        linear-gradient(180deg, #16161a 0%, var(--bg-2) 60%);
      font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      overflow:hidden;
    }
    #scene-wrap{position:fixed; inset:0}
    canvas{touch-action:none}

    .panel{
      position:fixed; right:16px; top:16px; z-index:5;
      background:var(--glass); backdrop-filter: blur(10px);
      border:1px solid var(--glass-bd); border-radius:14px; padding:12px 14px; min-width:220px;
      box-shadow:0 6px 30px rgba(0,0,0,0.35);
    }
    .panel h3{font:700 14px Orbitron,Inter,sans-serif; letter-spacing:1.5px; margin:0 0 8px; color:#ffd27a}
    .row{display:flex; gap:10px; align-items:center; margin:8px 0}
    .btn{
      appearance:none; border:1px solid var(--glass-bd); background:rgba(255,255,255,0.06);
      color:var(--txt); border-radius:12px; font:600 13px Inter,system-ui; padding:8px 12px; cursor:pointer;
    }
    .hint{font-size:12px; color:var(--muted); margin-top:4px}

    .title{ position:fixed; left:50%; top:24px; transform:translateX(-50%);
      font:700 16px Orbitron,Inter,sans-serif; letter-spacing:2px; text-transform:uppercase;
      color:var(--muted); opacity:0.9; z-index:4; display:none; }
    @media (min-width: 860px){ .title{display:block;} }
  </style>
</head>
<body>
  <div id="scene-wrap"></div>

  <div class="title">LDS Museum — Gallery</div>

  <div class="panel" id="panel">
    <h3>VR</h3>
    <div class="row">
      <button class="btn" id="vrBtn">Enter VR</button>
    </div>
    <div class="hint">WebXR works in Chrome/Edge (Android) and Quest Browser.</div>
  </div>

  <script type="module">
    // Local module paths (same as your project)
    import * as THREE from '/three3.js';
    import { OrbitControls } from '/orbit.js';

    const IS_MOBILE = /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i.test(navigator.userAgent) || (window.matchMedia && matchMedia('(pointer:coarse)').matches);

    // Core
    let scene, camera, renderer, controls, floor;
    const raycaster = new THREE.Raycaster();
    const pointer   = new THREE.Vector2();

    // Renderer
    const wrap = document.getElementById('scene-wrap');
    renderer = new THREE.WebGLRenderer({ antialias: !IS_MOBILE, alpha: true, powerPreference: 'high-performance' });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(IS_MOBILE ? Math.min(devicePixelRatio, 1.5) : Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = !IS_MOBILE;
    if (!IS_MOBILE && THREE.PCFSoftShadowMap) renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    wrap.appendChild(renderer.domElement);
    renderer.domElement.style.touchAction = 'none';

    // WebXR
    renderer.xr.enabled = true;

    // Scene + camera + controls
    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0a0a0d, 28, 160);

    camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 200);
    camera.position.set(0, 1.6, 12);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.06;
    controls.enablePan = true; controls.screenSpacePanning = true;
    controls.rotateSpeed = 0.9; controls.zoomSpeed = 0.8; controls.panSpeed = 0.6;
    controls.minDistance = 1.2; controls.maxDistance = 80.0; controls.maxPolarAngle = Math.PI * 0.49;
    controls.target.set(0, 1.3, -10);
    if ('zoomToCursor' in controls) controls.zoomToCursor = true;

    // XR rig
    const xrRig = new THREE.Group();
    scene.add(xrRig);
    xrRig.add(camera);

    renderer.xr.addEventListener('sessionstart', ()=>{ controls.enabled = false; });
    renderer.xr.addEventListener('sessionend',   ()=>{ controls.enabled = true;  });

    addEventListener('resize', () => {
      camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // ========== LIGHTING ==========
    // Ambient + hemi for museum bounce
    scene.add(new THREE.AmbientLight(0xf2efe9, 0.24));
    const hemi = new THREE.HemisphereLight(0xffffff, 0x1a1a20, IS_MOBILE ? 0.25 : 0.18);
    scene.add(hemi);

    // Key overhead soft lights (track style)
    const overhead = new THREE.SpotLight(0xffffff, 0.55, 0, Math.PI/5, 0.35, 1.4);
    overhead.position.set(0, 6.8, -8);
    overhead.castShadow = !IS_MOBILE; scene.add(overhead);
    const overhead2 = overhead.clone(); overhead2.position.set(0, 6.8, -24); scene.add(overhead2);

    // ========== ARCHITECTURE ==========
    // Procedural marble floor (canvas)
    function makeMarble(size=1024, tiles=8){
      const c = document.createElement('canvas'); c.width = c.height = size;
      const ctx = c.getContext('2d');
      // base
      ctx.fillStyle = '#e7e3dd'; ctx.fillRect(0,0,size,size);
      // subtle veins
      ctx.globalAlpha = 0.08;
      for (let i=0;i<50;i++){
        const x = Math.random()*size, y=Math.random()*size, r=40+Math.random()*160;
        const g = ctx.createRadialGradient(x,y,0,x,y,r);
        g.addColorStop(0, 'rgba(80,80,90,0.8)');
        g.addColorStop(1, 'rgba(80,80,90,0)');
        ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
      }
      // tile lines
      ctx.globalAlpha = 0.35; ctx.strokeStyle = 'rgba(30,30,35,0.25)'; ctx.lineWidth = 2;
      const step = size/tiles;
      for (let i=1;i<tiles;i++){ ctx.beginPath(); ctx.moveTo(i*step,0); ctx.lineTo(i*step,size); ctx.stroke();
                                 ctx.beginPath(); ctx.moveTo(0,i*step); ctx.lineTo(size,i*step); ctx.stroke(); }
      const tex = new THREE.CanvasTexture(c); tex.wrapS=tex.wrapT=THREE.RepeatWrapping; tex.repeat.set(4,12);
      tex.anisotropy = 4; return tex;
    }

    // Room shell (tall hall)
    const hall = new THREE.Mesh(
      new THREE.BoxGeometry(26, 10, 80),
      new THREE.MeshStandardMaterial({ color:0x1b1b1f, roughness:0.95, metalness:0.05, side:THREE.BackSide })
    );
    scene.add(hall);

    // Floor
    floor = new THREE.Mesh(
      new THREE.PlaneGeometry(50, 160),
      new THREE.MeshStandardMaterial({ map: makeMarble(), roughness:0.85, metalness:0.05 })
    );
    floor.rotation.x = -Math.PI/2; floor.receiveShadow = !IS_MOBILE; scene.add(floor);

    // Columns & arches
    function addColumn(x,z){
      const colMat = new THREE.MeshStandardMaterial({ color:0xdddddd, roughness:0.8, metalness:0.05 });
      const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.4,0.42,7.2,16), colMat);
      const base  = new THREE.Mesh(new THREE.CylinderGeometry(0.55,0.6,0.3,16), colMat);
      const cap   = new THREE.Mesh(new THREE.CylinderGeometry(0.5,0.52,0.3,16), colMat);
      shaft.position.set(x, 3.8, z); base.position.set(x, 0.15, z); cap.position.set(x, 7.1, z);
      shaft.castShadow = cap.castShadow = base.receiveShadow = !IS_MOBILE;
      scene.add(shaft, base, cap);
      return {shaft, cap};
    }
    function addArch(a, b){
      const span = new THREE.Vector3().subVectors(b, a); const mid = new THREE.Vector3().addVectors(a,b).multiplyScalar(0.5);
      const len = span.length();
      const arc = new THREE.Mesh(
        new THREE.TorusGeometry(len*0.5, 0.18, 12, 48, Math.PI),
        new THREE.MeshStandardMaterial({ color:0xdddddd, roughness:0.8, metalness:0.05 })
      );
      arc.rotation.set(0, Math.atan2(span.z, span.x)+Math.PI, Math.PI);
      arc.position.set(mid.x, 7.1, mid.z);
      arc.castShadow = !IS_MOBILE; scene.add(arc); return arc;
    }

    const colPairsZ = [-6, -18, -30, -42, -54];
    colPairsZ.forEach(z=>{
      const L = addColumn(-10, z); const R = addColumn(10, z);
      addArch(new THREE.Vector3(-10,7.1,z), new THREE.Vector3(10,7.1,z));
    });

    // Wall sconces with lights
    function addSconce(x,y,z){
      const back = new THREE.Mesh(new THREE.CylinderGeometry(0.18,0.22,0.1,12), new THREE.MeshStandardMaterial({ color:0x333336, roughness:0.6 }));
      back.rotation.z = Math.PI/2; back.position.set(x,y,z);
      const bowl = new THREE.Mesh(new THREE.SphereGeometry(0.18, 12, 8, 0, Math.PI), new THREE.MeshStandardMaterial({ color:0xf7f2d6, emissive:0xf0e7c2, emissiveIntensity:0.6, roughness:0.5 }));
      bowl.rotation.x = Math.PI; bowl.position.set(x,y,z+0.05);
      const light = new THREE.PointLight(0xfff2c4, 0.9, 10, 2.0); light.position.set(x,y,z+0.05);
      scene.add(back, bowl, light);
    }
    for (let i=0;i<colPairsZ.length;i++){
      addSconce(-8.5, 3.6, colPairsZ[i]+0.2);
      addSconce( 8.5, 3.6, colPairsZ[i]+0.2);
    }

    // ========== LABEL HELPERS ==========
    function makeLabel(text) {
      const c = document.createElement('canvas'), p=16, fs=34;
      const ctx = c.getContext('2d');
      ctx.font = `bold ${fs}px Inter, Arial`;
      const w = Math.ceil(ctx.measureText(text).width) + p*2; const h = fs + p*2;
      c.width = w; c.height = h; const c2 = c.getContext('2d'); c2.font = `bold ${fs}px Inter, Arial`;
      c2.fillStyle='rgba(24,12,20,0.85)'; c2.strokeStyle='rgba(255,255,255,0.25)'; c2.lineWidth=4;
      c2.beginPath(); const r=18; c2.moveTo(r,0); c2.arcTo(w,0,w,h,r); c2.arcTo(w,h,0,h,r); c2.arcTo(0,h,0,0,r); c2.arcTo(0,0,w,0,r); c2.closePath();
      c2.fill(); c2.stroke();
      c2.fillStyle='#fff6e9'; c2.textAlign='center'; c2.textBaseline='middle'; c2.fillText(text,w/2,h/2);
      const tex = new THREE.CanvasTexture(c); tex.minFilter = THREE.LinearFilter;
      const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent:true, depthWrite:false }));
      const s=0.008; spr.scale.set(w*s, h*s, 1); return spr;
    }
    function makeSub(text){
      const c = document.createElement('canvas'), p=12, fs=22; const ctx = c.getContext('2d');
      ctx.font = `600 ${fs}px Inter, Arial`; const w = Math.ceil(ctx.measureText(text).width) + p*2; const h = fs + p*2; c.width = w; c.height = h;
      const g = c.getContext('2d'); g.font = `600 ${fs}px Inter, Arial`; g.fillStyle='rgba(255,255,255,0.78)'; g.textAlign='center'; g.textBaseline='middle'; g.fillText(text,w/2,h/2);
      const tex = new THREE.CanvasTexture(c); tex.minFilter = THREE.LinearFilter;
      const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent:true, depthWrite:false }));
      const s=0.006; spr.scale.set(w*s, h*s, 1); return spr;
    }

    // Pedestal (stone)
    function makePedestal({wTop=0.75,wBot=0.85,h=0.6}={}){
      const grp = new THREE.Group();
      const stone = new THREE.MeshStandardMaterial({ color:0xb8b3ab, roughness:0.75, metalness:0.05 });
      const base  = new THREE.Mesh(new THREE.CylinderGeometry(wBot,wBot,0.12,24), stone);
      const core  = new THREE.Mesh(new THREE.CylinderGeometry(wTop,wTop, h,24), stone);
      const cap   = new THREE.Mesh(new THREE.CylinderGeometry(wTop*0.95, wTop*0.95,0.06,24), stone);
      base.position.y = 0.06; core.position.y = h*0.5+0.12; cap.position.y = h+0.15;
      [base,core,cap].forEach(m=>{ m.receiveShadow = !IS_MOBILE; m.castShadow = !IS_MOBILE; });
      grp.add(base,core,cap); grp.userData.topY = cap.position.y+0.03;
      return grp;
    }

    // Exhibit builder
    function addExhibit({ name, sub, pos = {x:0,y:0,z:0}, buildMesh, spotlight=true } = {}) {
      const group = new THREE.Group();
      group.position.set(pos.x||0, pos.y||0, pos.z||0);

      const pedestal = makePedestal(); group.add(pedestal);
      const builder = (typeof buildMesh === 'function') ? buildMesh : ()=> new THREE.Group();
      let mesh = builder();
      if (!mesh || !(mesh && mesh.isObject3D)) { console.warn('[addExhibit] buildMesh did not return Object3D for', name); mesh = new THREE.Group(); }
      mesh.position.y = pedestal.userData.topY || 0.95;
      if (mesh.castShadow !== undefined){ mesh.castShadow = !IS_MOBILE; mesh.receiveShadow = !IS_MOBILE; }
      group.add(mesh);

      const label = makeLabel(name); label.position.set(0, (pedestal.userData.topY||1.0)+0.85, 0); group.add(label);
      if (sub){ const l2 = makeSub(sub); l2.position.set(0, (pedestal.userData.topY||1.0)+0.55, 0); group.add(l2); }

      if (!IS_MOBILE && spotlight){
        const spot = new THREE.SpotLight(0xffffff, 0.85, 8, Math.PI/8, 0.4, 1.6);
        spot.position.set(group.position.x+0.8, 4.8, group.position.z+0.8);
        spot.target = mesh; spot.castShadow = true; group.add(spot, spot.target);
      }
      scene.add(group); return group;
    }

    // Small utilities
    function goldMaterial(){ return new THREE.MeshStandardMaterial({ color:0xD4AF37, metalness:1.0, roughness:0.32 }); }
    function brassMaterial(){ return new THREE.MeshStandardMaterial({ color:0xCCA63D, metalness:0.85, roughness:0.35 }); }
    function stoneMaterial(){ return new THREE.MeshStandardMaterial({ color:0xbfbab2, metalness:0.0, roughness:0.95 }); }
    function rockMaterial(){ return new THREE.MeshStandardMaterial({ color:0x9a9a9a, metalness:0.0, roughness:0.98 }); }

    // ========== LDS EXHIBITS (Low-poly, literal) ==========

    // 1) Salt Lake Temple (stylized low-poly)
    function buildTemple(){
      const g = new THREE.Group();
      const mat = stoneMaterial();
      // main nave
      const nave = new THREE.Mesh(new THREE.BoxGeometry(1.4, 1.0, 0.6), mat); nave.position.y = 0.5; g.add(nave);
      // side towers
      const towerGeo = new THREE.BoxGeometry(0.28, 1.6, 0.28);
      const T1 = new THREE.Mesh(towerGeo, mat), T2 = T1.clone(), T3 = T1.clone(), T4 = T1.clone();
      T1.position.set(-0.55, 0.8,  0.18); T2.position.set(0.55, 0.8,  0.18);
      T3.position.set(-0.55, 0.8, -0.18); T4.position.set(0.55, 0.8, -0.18);
      g.add(T1,T2,T3,T4);
      // center tower
      const center = new THREE.Mesh(new THREE.BoxGeometry(0.35, 1.9, 0.35), mat); center.position.set(0, 0.95, 0); g.add(center);
      // spires
      function spire(h=0.35){ return new THREE.Mesh(new THREE.ConeGeometry(0.12, h, 8), mat); }
      const s1=spire(), s2=spire(), s3=spire(), s4=spire(), sC=new THREE.Mesh(new THREE.ConeGeometry(0.14,0.5,8), mat);
      s1.position.copy(T1.position).y = 1.7; s2.position.copy(T2.position).y = 1.7; s3.position.copy(T3.position).y = 1.7; s4.position.copy(T4.position).y = 1.7;
      sC.position.set(0, 2.2, 0); g.add(s1,s2,s3,s4,sC);
      // tiny Moroni atop center (gold)
      const mor = new THREE.Group();
      const body = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.22, 8), goldMaterial()); body.position.y = 0.11;
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.035, 10, 8), goldMaterial()); head.position.y = 0.25;
      const trumpet = new THREE.Mesh(new THREE.CylinderGeometry(0.005, 0.02, 0.18, 8), goldMaterial()); trumpet.rotation.x = -Math.PI/4; trumpet.position.set(0, 0.28, 0.05);
      mor.add(body, head, trumpet); mor.position.set(0, 2.48, 0); g.add(mor);
      g.userData.update = ()=>{ g.rotation.y += 0.03; };
      return g;
    }

    // 2) Angel Moroni (standalone)
    function buildMoroni(){
      const g = new THREE.Group(); const mat = goldMaterial();
      const robe = new THREE.Mesh(new THREE.ConeGeometry(0.12, 0.7, 12), mat); robe.position.y = 0.35;
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.08, 14, 12), mat); head.position.y = 0.75;
      const arm  = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 0.35, 8), mat); arm.position.set(0.12, 0.64, 0); arm.rotation.z = -Math.PI/6;
      const trumpet = new THREE.Mesh(new THREE.CylinderGeometry(0.006, 0.03, 0.48, 10), mat); trumpet.rotation.x = -Math.PI/4; trumpet.position.set(0.2, 0.8, 0.08);
      g.add(robe, head, arm, trumpet);
      g.userData.update = ()=>{ g.rotation.y += 0.08; };
      return g;
    }

    // 3) Golden Plates
    function buildPlates(){
      const g = new THREE.Group();
      const plates = new THREE.Mesh(new THREE.BoxGeometry(0.28, 0.08, 0.2), goldMaterial());
      plates.position.y = 0.04; g.add(plates);
      const ringGeo = new THREE.TorusGeometry(0.065, 0.008, 8, 16);
      for (let i=0;i<3;i++){ const r = new THREE.Mesh(ringGeo, goldMaterial()); r.rotation.x = Math.PI/2; r.position.set(-0.12, 0.06, -0.06 + i*0.06); g.add(r); }
      g.userData.update = ()=>{ plates.rotation.y += 0.06; };
      return g;
    }

    // 4) Book of Mormon (closed book with canvas cover)
    function buildBook(){
      const g = new THREE.Group();
      const coverTex = (()=>{ const c=document.createElement('canvas'); c.width=c.height=256; const x=c.getContext('2d');
        x.fillStyle='#0f2442'; x.fillRect(0,0,256,256); x.fillStyle='#d9c26b'; x.font='bold 34px Inter, Arial';
        x.textAlign='center'; x.textBaseline='middle'; x.fillText('BOOK OF',128,110); x.fillText('MORMON',128,150);
        x.strokeStyle='#d9c26b'; x.lineWidth=8; x.strokeRect(18,18,220,220); const t=new THREE.CanvasTexture(c); t.anisotropy=4; return t;})();
      const coverMat = new THREE.MeshStandardMaterial({ map: coverTex, roughness:0.6, metalness:0.1 });
      const sideMat  = new THREE.MeshStandardMaterial({ color:0xcfbf9a, roughness:0.9, metalness:0.0 });
      const geo = new THREE.BoxGeometry(0.22, 0.035, 0.16);
      // assign different mats per face: [px,nx,py,ny,pz,nz]
      const mats = [sideMat, sideMat, sideMat, sideMat, coverMat, sideMat];
      const book  = new THREE.Mesh(geo, mats);
      book.position.y = 0.02; g.add(book);
      g.userData.update = ()=>{ book.rotation.y += 0.04; };
      return g;
    }

    // 5) Liahona (brass sphere with inner spindles)
    function buildLiahona(){
      const g = new THREE.Group();
      const shell = new THREE.Mesh(new THREE.SphereGeometry(0.18, 16, 12), brassMaterial());
      shell.material.transparent = true; shell.material.opacity = 0.75;
      g.add(shell);
      const ptrGrp = new THREE.Group();
      const rod = new THREE.Mesh(new THREE.CylinderGeometry(0.01,0.01,0.34,8), new THREE.MeshStandardMaterial({ color:0xffffff, metalness:0.1, roughness:0.6 }));
      rod.rotation.z = Math.PI/2; const rod2 = rod.clone(); rod2.rotation.x = Math.PI/2;
      ptrGrp.add(rod, rod2); g.add(ptrGrp);
      g.userData.update = ()=>{ ptrGrp.rotation.y += 0.5; };
      return g;
    }

    // 6) Tree of Life (low-poly trunk + glowing fruit)
    function buildTree(){
      const g = new THREE.Group();
      const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.07, 0.12, 0.9, 6), new THREE.MeshStandardMaterial({ color:0x7a4f2b, roughness:0.9 }));
      trunk.position.y = 0.45; g.add(trunk);
      const canopyMat = new THREE.MeshStandardMaterial({ color:0xffffff, emissive:0xffffff, emissiveIntensity:0.6, roughness:0.4 });
      const blobs = [];
      const centers = [[0,0.92,0],[0.18,0.82,0],[-0.18,0.82,0],[0,0.8,0.18],[0,0.8,-0.18]];
      centers.forEach(p=>{ const s=new THREE.Mesh(new THREE.SphereGeometry(0.18, 12, 10), canopyMat); s.position.set(...p); g.add(s); blobs.push(s); });
      // fruit
      for(let i=0;i<12;i++){ const f=new THREE.Mesh(new THREE.SphereGeometry(0.04, 10, 8), canopyMat); f.position.set((Math.random()-0.5)*0.35, 0.8+Math.random()*0.15, (Math.random()-0.5)*0.35); g.add(f); }
      return g;
    }

    // 7) Iron Rod (railing)
    function buildIronRod(){
      const g = new THREE.Group();
      const railMat = new THREE.MeshStandardMaterial({ color:0x6d6d70, metalness:0.8, roughness:0.35 });
      const base = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.02, 0.24), stoneMaterial()); base.position.y = 0.01; g.add(base);
      for (let i=0;i<6;i++){
        const post = new THREE.Mesh(new THREE.CylinderGeometry(0.015,0.015,0.5,8), railMat); post.position.set(-0.42+i*0.17, 0.25, 0); g.add(post);
      }
      const rail = new THREE.Mesh(new THREE.CylinderGeometry(0.02,0.02,0.9,12), railMat); rail.rotation.z = Math.PI/2; rail.position.y = 0.5; g.add(rail);
      return g;
    }

    // 8) First Vision (mini sacred grove + light shaft)
    function buildFirstVision(){
      const g = new THREE.Group();
      // ground disk
      const ground = new THREE.Mesh(new THREE.CylinderGeometry(0.6,0.6,0.04,24), new THREE.MeshStandardMaterial({ color:0x2f3a2f, roughness:0.95 }));
      ground.position.y = 0.02; g.add(ground);
      // simple trees
      function tree(x,z){
        const t = new THREE.Group();
        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.05,0.5,6), new THREE.MeshStandardMaterial({ color:0x7a4f2b, roughness:0.9 }));
        trunk.position.y = 0.25; t.add(trunk);
        const crown = new THREE.Mesh(new THREE.SphereGeometry(0.18, 10, 8), new THREE.MeshStandardMaterial({ color:0x9fc79f, roughness:0.8 }));
        crown.position.y = 0.52; t.add(crown);
        t.position.set(x,0,z); return t;
      }
      g.add(tree(-0.25,-0.12), tree(0.25,0.10), tree(0.05,-0.25));
      // light shaft (transparent cone + spot)
      const cone = new THREE.Mesh(new THREE.ConeGeometry(0.35, 0.7, 16), new THREE.MeshBasicMaterial({ color:0xffffff, transparent:true, opacity:0.18 }));
      cone.position.y = 0.65; cone.rotation.x = Math.PI; g.add(cone);
      const spot = new THREE.SpotLight(0xffffff, 0.8, 2.0, Math.PI/6, 0.4, 1.6); spot.position.set(0, 1.3, 0.0); spot.target = ground; g.add(spot, spot.target);
      return g;
    }

    // 9) Ten Commandments (stone tablets with rounded top)
    function buildTablets(){
      const g = new THREE.Group(); const mat = rockMaterial();
      function tablet(){
        const w=0.32, h=0.44, r=0.16;
        const shape = new THREE.Shape();
        shape.moveTo(-w/2,0); shape.lineTo(-w/2,h-r); shape.absarc(0,h-r,r,Math.PI,0,false); shape.lineTo(w/2,0); shape.lineTo(-w/2,0);
        const geo = new THREE.ExtrudeGeometry(shape,{ depth:0.04, bevelEnabled:false });
        return new THREE.Mesh(geo, mat);
      }
      const A = tablet(); const B = tablet();
      A.rotation.y = Math.PI + 0.08; B.rotation.y = Math.PI - 0.08; A.position.x = -0.18; B.position.x = 0.18; A.position.y = B.position.y = 0.22;
      g.add(A,B);
      return g;
    }

    // 10) Beehive (skep)
    function buildBeehive(){
      const g = new THREE.Group();
      const mat = new THREE.MeshStandardMaterial({ color:0xd2b48c, roughness:0.9, metalness:0.05 });
      const rings = [0.26,0.22,0.18,0.14].map((R,i)=>{ const t=new THREE.Mesh(new THREE.TorusGeometry(R, 0.04-(i*0.006), 10, 24), mat); t.position.y = 0.08 + i*0.1; return t; });
      rings.forEach(r=>g.add(r));
      const cap = new THREE.Mesh(new THREE.SphereGeometry(0.1, 10, 8), mat); cap.position.y = 0.5; g.add(cap);
      const hole = new THREE.Mesh(new THREE.CylinderGeometry(0.028,0.028,0.01,8), new THREE.MeshStandardMaterial({ color:0x000000 })); hole.rotation.x = Math.PI/2; hole.position.set(0, 0.12, -0.24);
      g.add(hole);
      return g;
    }

    // ===== Place exhibits (two rows down the hall) =====
    const exTemple = addExhibit({ name:'Salt Lake Temple', sub:'Symbolic Model', pos:{x:-6.5, y:0, z:-10}, buildMesh: buildTemple });
    const exMoroni = addExhibit({ name:'Angel Moroni', sub:'Trumpeting Angel', pos:{x:-2.5, y:0, z:-12}, buildMesh: buildMoroni });
    const exPlates = addExhibit({ name:'Golden Plates', sub:'Source of Translation', pos:{x: 1.0, y:0, z:-14}, buildMesh: buildPlates });
    const exBook   = addExhibit({ name:'Book of Mormon', sub:'Sacred Record', pos:{x: 4.5, y:0, z:-12}, buildMesh: buildBook });

    const exLiah   = addExhibit({ name:'Liahona', sub:'Divine Compass', pos:{x:-6.5, y:0, z:-22}, buildMesh: buildLiahona });
    const exTree   = addExhibit({ name:'Tree of Life', sub:'Lehi’s Vision', pos:{x:-2.5, y:0, z:-24}, buildMesh: buildTree });
    const exRod    = addExhibit({ name:'Iron Rod', sub:'Hold Fast to the Path', pos:{x: 1.0, y:0, z:-26}, buildMesh: buildIronRod, spotlight:false });
    const exFirst  = addExhibit({ name:'The First Vision', sub:'Sacred Grove', pos:{x: 4.5, y:0, z:-24}, buildMesh: buildFirstVision });
    const exTabs   = addExhibit({ name:'Ten Commandments', sub:'Tablets of Law', pos:{x:-1.0, y:0, z:-34}, buildMesh: buildTablets });
    const exBee    = addExhibit({ name:'Beehive', sub:'Industry & Unity', pos:{x: 3.0, y:0, z:-34}, buildMesh: buildBeehive });

    // ========== VR Helpers ==========
    const controller = renderer.xr.getController(0);
    xrRig.add(controller);
    const controllerGeo = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1) ]);
    const controllerRay = new THREE.Line(controllerGeo, new THREE.LineBasicMaterial({ transparent:true, opacity:0.9 }));
    controllerRay.name = 'controllerRay'; controllerRay.scale.z = 10; controller.add(controllerRay);

    const reticle = new THREE.Mesh(new THREE.RingGeometry(0.15, 0.17, 32), new THREE.MeshBasicMaterial({ transparent:true, opacity:0.85, side:THREE.DoubleSide }));
    reticle.rotation.x = -Math.PI/2; reticle.visible = false; scene.add(reticle);

    const tempMatrix = new THREE.Matrix4();
    function intersectController(ctrl, objects){
      tempMatrix.identity().extractRotation(ctrl.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(ctrl.matrixWorld);
      raycaster.ray.direction.set(0,0,-1).applyMatrix4(tempMatrix);
      const hits = raycaster.intersectObjects(objects, true);
      return hits[0] || null;
    }
    function tryTeleport(){
      if (!renderer.xr.isPresenting) return;
      const hit = intersectController(controller, [floor]);
      if (hit){ xrRig.position.set(hit.point.x, 0, hit.point.z); }
    }
    controller.addEventListener('select', tryTeleport);

    // Pointer focus (dblclick / double-tap)
    function setPointer(e){
      const rect = renderer.domElement.getBoundingClientRect(); const cx = e.touches ? e.touches[0].clientX : e.clientX; const cy = e.touches ? e.touches[0].clientY : e.clientY;
      pointer.x = ((cx - rect.left) / rect.width) * 2 - 1; pointer.y = -((cy - rect.top) / rect.height) * 2 + 1;
    }
    function focusAtPointer(e){
      setPointer(e); raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects([exTemple, exMoroni, exPlates, exBook, exLiah, exTree, exRod, exFirst, exTabs, exBee, floor], true);
      if (!hits.length) return; const p = hits[0].point; const dist = camera.position.distanceTo(controls.target); const dir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
      const newCamPos = new THREE.Vector3().copy(p).addScaledVector(dir, dist);
      const start = performance.now(); const fromCam = camera.position.clone(); const fromTgt = controls.target.clone(); const ease = t => 1 - Math.pow(1 - t, 3);
      (function step(now){ const t = Math.min(1, (now - start) / 420); const e2 = ease(t); camera.position.lerpVectors(fromCam, newCamPos, e2); controls.target.lerpVectors(fromTgt, p, e2); if (t < 1) requestAnimationFrame(step); })(start);
    }
    renderer.domElement.addEventListener('dblclick', focusAtPointer, { passive:true });
    let lastTapTime = 0, lastTapX=0, lastTapY=0; renderer.domElement.addEventListener('touchend', (e)=>{
      if (!e.changedTouches || e.changedTouches.length!==1) return; const touch = e.changedTouches[0]; const now = performance.now();
      const dt = now - lastTapTime; const dx = touch.clientX - lastTapX; const dy = touch.clientY - lastTapY; lastTapTime = now; lastTapX = touch.clientX; lastTapY = touch.clientY;
      if (dt < 320 && (dx*dx+dy*dy) < (24*24)) focusAtPointer({ touches:[touch] });
    }, { passive:true });

    // Animation clock
    const clock = new THREE.Clock();

    function renderLoop(){
      const t = clock.getElapsedTime();
      controls.update();

      // keep target sensible
      const tgt = controls.target; tgt.x = Math.max(-8, Math.min(8, tgt.x)); tgt.y = Math.max(0.5, Math.min(3.5, tgt.y)); tgt.z = Math.max(-120, Math.min(-6, tgt.z));

      // per-exhibit gentle updates
      [exTemple, exMoroni, exPlates, exBook, exLiah, exTree, exRod, exFirst, exTabs, exBee].forEach(g=>{
        const up = g.children.find(o=>o.userData && o.userData.update);
        if (up && up.userData.update) up.userData.update(t);
        if (g.userData.update) g.userData.update(t);
      });

      // VR reticle update
      if (renderer.xr.isPresenting){
        const hit = intersectController(controller, [floor]);
        if (hit){ reticle.position.copy(hit.point); reticle.visible = true; } else { reticle.visible = false; }
      } else { reticle.visible = false; }

      renderer.render(scene, camera);
    }
    renderer.setAnimationLoop(renderLoop);

    // UI: Single VR button (same flow)
    const vrBtn = document.getElementById('vrBtn');
    let currentSession = null;
    if (vrBtn){
      vrBtn.addEventListener('click', async ()=>{
        if (!('xr' in navigator)){
          alert('WebXR not supported on this device/browser. Try Chrome on Android or the Quest Browser.');
          return;
        }
        if (!currentSession){
          try {
            const session = await navigator.xr.requestSession('immersive-vr', { requiredFeatures: ['local-floor'] });
            currentSession = session;
            session.addEventListener('end', ()=>{ currentSession = null; vrBtn.textContent = 'Enter VR'; });
            await renderer.xr.setSession(session);
            vrBtn.textContent = 'Exit VR';
          } catch (e) {
            console.warn('VR start failed:', e);
            alert('Unable to start VR: ' + (e?.message ?? e));
          }
        } else { currentSession.end(); }
      });
    }
  </script>
</body>
</html>
