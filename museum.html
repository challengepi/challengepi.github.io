<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Cosmic Waves Museum — Space & Radio Astronomy</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0b0f22" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&family=Inter:wght@300;500;700&display=swap" rel="stylesheet">
  <style>
    :root { --bg:#0b0f22; --bg-2:#0a0d1b; --txt:#e6ebff; --muted:#9aa4c7; --glass:rgba(255,255,255,0.06); --glass-bd:rgba(255,255,255,0.12); }
    *{box-sizing:border-box} html,body{height:100%}
    body{margin:0;background:radial-gradient(1200px 800px at 70% -10%, #18204b 0%, var(--bg) 60%), var(--bg-2);
         color:var(--txt);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;overflow:hidden}
    #scene-wrap{position:fixed;inset:0}
    canvas{touch-action:none} /* important for mobile pinch/rotate to work well */

    /* Hide default UI layers: only 3D museum remains visible */
    .ui, .ui-toggle, .mobile-tip { display:none !important; }

    .ui{position:fixed;inset:0;pointer-events:none;display:grid;grid-template-rows:auto 1fr auto;
        padding:env(safe-area-inset-top) clamp(12px,2vw,24px) env(safe-area-inset-bottom);
        transition:opacity .2s ease, transform .2s ease}
    .topbar,.footer{display:flex;align-items:center;gap:12px;pointer-events:auto}
    .topbar{justify-content:space-between;padding:clamp(10px,1.5vw,16px) clamp(12px,2vw,24px)}
    .brand{display:flex;align-items:baseline;gap:10px;font-family:Orbitron,Inter,sans-serif;letter-spacing:.5px}
    .brand h1{margin:0;font-size:clamp(18px,2vw,26px);font-weight:700;background:linear-gradient(90deg,#dfe7ff,#a7b8ff);
      -webkit-background-clip:text;background-clip:text;color:transparent}
    .brand .tagline{color:var(--muted);font-size:clamp(12px,1.4vw,14px)}

    .hero{pointer-events:none;display:grid;place-items:start center;padding-top:clamp(12px,6vh,60px);text-shadow:0 2px 24px rgba(0,0,0,.6)}
    .hero h2{margin:0 12px;font-family:Orbitron,Inter,sans-serif;font-size:clamp(22px,3vw,40px);letter-spacing:1px}
    .hero p{margin:8px 12px 0;color:var(--muted);font-size:clamp(13px,1.8vw,16px);max-width:800px;text-align:center}

    .cta-wrap{pointer-events:auto;display:grid;gap:12px;justify-content:center;text-align:center;margin-top:clamp(12px,2.5vh,36px)}
    .btn{appearance:none;border:1px solid var(--glass-bd);background:linear-gradient(180deg,rgba(255,255,255,.14),rgba(255,255,255,.04));
         color:var(--txt);padding:12px 18px;border-radius:14px;font-weight:600;letter-spacing:.3px;backdrop-filter:blur(8px);
         cursor:pointer;transition:transform .1s ease,border-color .2s ease,background .2s ease;box-shadow:0 10px 30px rgba(63,90,255,.15) inset,0 6px 18px rgba(0,0,0,.25)}
    .btn:hover{transform:translateY(-1px);border-color:rgba(255,255,255,.25)}
    .btn.primary{border-color:rgba(122,167,255,.6);background:linear-gradient(180deg,rgba(122,167,255,.25),rgba(122,167,255,.08))}
    .btn.secondary{background:rgba(255,255,255,.06)}
    .chip{border:1px solid var(--glass-bd);background:var(--glass);padding:6px 10px;border-radius:999px;font-size:12px;color:var(--muted)}

    .footer{justify-content:center;gap:16px;padding:10px 16px 24px}
    .mobile-tip{position:fixed;left:50%;bottom:14px;transform:translateX(-50%);font-size:12px;color:var(--muted);
                background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.12);border-radius:999px;padding:6px 12px;pointer-events:none}

    .quick { pointer-events:auto; display:flex; gap:8px; justify-content:center; margin-top:10px; flex-wrap:wrap; max-width:min(900px,92vw); margin-inline:auto}
    .mini { font-size:12px; padding:8px 10px; border-radius:10px; border:1px solid var(--glass-bd); background:rgba(255,255,255,0.05); color:var(--txt); cursor:pointer;}
    .mini:hover{border-color:rgba(255,255,255,.25)}

    .ui-toggle{position:fixed;top:10px;right:10px; z-index:10; pointer-events:auto; display:flex; gap:8px}
    .ui-toggle button{appearance:none; border:1px solid var(--glass-bd); background:rgba(255,255,255,.08); color:var(--txt);
      padding:8px 10px; border-radius:10px; font-weight:700; cursor:pointer}

    body.ui-hidden .ui{opacity:0; transform:translateY(-8px); visibility:hidden; pointer-events:none}
    body.ui-hidden .ui *{pointer-events:none !important}
    body.ui-hidden .mobile-tip{opacity:0}
  </style>
</head>
<body>
  <div id="scene-wrap"></div>

  <!-- UI toggle + Reset View (kept in DOM but hidden by CSS above) -->
  <div class="ui-toggle">
    <button id="uiToggle" aria-pressed="false" title="Hide/Show UI">UI</button>
    <button id="resetView" title="Reset View">Reset</button>
  </div>

  <div class="ui">
    <div class="topbar">
      <div class="brand">
        <h1>Cosmic Waves Museum</h1>
        <span class="tagline">Space & Radio Astronomy</span>
      </div>
      <div class="chip">Mobile-ready · Tap exhibits · Double-tap to refocus</div>
    </div>

    <div class="hero">
      <div>
        <h2>Step into the star-lit gallery</h2>
        <p>Drag to look, pinch to zoom. Tap a pedestal (or panel) to open its page.</p>
        <div class="cta-wrap">
          <button id="enterBtn" class="btn primary">Enter Museum</button>
          <button id="exhibitsBtn" class="btn secondary">View Exhibits List</button>
          <div class="quick" id="quickLinks">
            <button class="mini" data-link="#">Planetary Sculpture</button>
            <button class="mini" data-link="dish.html">Radio Dish Form</button>
            <button class="mini" data-link="#">Launch Totem</button>
            <button class="mini" data-link="wavestatue.html">Wave Statue</button>
            <button class="mini" data-link="#">Pulsar Beacon</button>
            <button class="mini" data-link="#">CMB Tableau</button>
            <button class="mini" data-link="#">SKA Array Hall</button>
            <button class="mini" data-link="prism.html">Spectral Prism</button>
            <button class="mini" data-link="#">Interferometer Rings</button>
            <button class="mini" data-link="#">Nebula Cloud</button>
            <button class="mini" data-link="#">Binary Pair</button>
            <button class="mini" data-link="#">Gravitational Lens</button>
            <button class="mini" data-link="#">Solar Flare Helix</button>
            <button class="mini" data-link="antenna.html">Antenna Tower</button>
            <button class="mini" data-link="#">Mini Satellite</button>
            <button class="mini" data-link="meteor.html">Meteorite Fragment</button>
            <button class="mini" data-link="#">Data Cube</button>
          </div>
        </div>
      </div>
    </div>

    <div class="footer">
      <button id="spinBtn" class="btn">Toggle Spin</button>
    </div>
  </div>

  <div class="mobile-tip">Drag to look • Pinch to zoom • Double-tap to refocus • Tap exhibits</div>

  <script type="module">
    import { OrbitControls } from '/orbit.js';
    import * as THREE from '/three3.js';

    // --- Mobile detection for lighter path
    const IS_MOBILE =
      /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i.test(navigator.userAgent) ||
      (window.matchMedia && matchMedia("(pointer:coarse)").matches);

    let scene, camera, renderer, controls, floor;
    const clickable   = [];
    const rotatables  = []; // everything that slow-rotates
    const raycaster   = new THREE.Raycaster();
    const pointer     = new THREE.Vector2();
    let spinning      = true;

    // renderer / canvas
    const wrap = document.getElementById('scene-wrap');
    renderer = new THREE.WebGLRenderer({
      antialias: !IS_MOBILE,
      alpha: true,
      powerPreference: "high-performance"
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(IS_MOBILE ? Math.min(devicePixelRatio, 1.5)
                                     : Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = !IS_MOBILE; // shadows off on mobile
    if (!IS_MOBILE && THREE.PCFSoftShadowMap) renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    wrap.appendChild(renderer.domElement);
    renderer.domElement.style.touchAction = 'none'; // mobile gestures to controls

    // scene / camera / controls
    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x060814, 24, 180);

    camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 400);
    camera.position.set(0, 1.6, 12);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.enablePan = true;
    controls.screenSpacePanning = true;
    controls.rotateSpeed = 0.9;
    controls.zoomSpeed = 0.8;
    controls.panSpeed = 0.6;
    controls.minDistance = 1.2;
    controls.maxDistance = 80.0;
    controls.target.set(0, 1.3, -6);
    controls.maxPolarAngle = Math.PI * 0.49;
    if ('zoomToCursor' in controls) controls.zoomToCursor = true;

    addEventListener('resize', () => {
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.24));

    const key = new THREE.DirectionalLight(0xbfd7ff, 0.75);
    key.position.set(6, 10, 6);
    key.castShadow = !IS_MOBILE; // no shadow maps on mobile
    key.shadow.mapSize.set(1024, 1024);
    scene.add(key);

    // Soft sky/ground fill so Standard materials read without many spotlights
    const hemi = new THREE.HemisphereLight(0xbfd7ff, 0x0b0f26, IS_MOBILE ? 0.6 : 0.35);
    scene.add(hemi);

    const fill = new THREE.PointLight(0x8ea6ff, 0.55, 60, 1.5);
    fill.position.set(-4, 4, -2);
    scene.add(fill);

    // room (extended depth so walls cover all artefacts)
    const room = new THREE.Mesh(
      new THREE.BoxGeometry(22, 8, 220),
      new THREE.MeshStandardMaterial({ color:0x0f1330, roughness:0.9, metalness:0.05, side:THREE.BackSide })
    );
    scene.add(room);

    floor = new THREE.Mesh(
      new THREE.PlaneGeometry(40, 260),
      new THREE.MeshStandardMaterial({ color:0x0b0f26, roughness:0.2, metalness:0.4 })
    );
    floor.rotation.x = -Math.PI/2;
    floor.receiveShadow = !IS_MOBILE;
    scene.add(floor);

    // runway LEDs
    const runway = new THREE.Group();
    for (let i = -16; i >= -140; i -= 4) {
      const g = new THREE.SphereGeometry(0.05,16,16);
      const m = new THREE.MeshBasicMaterial({ color:0x7aa7ff });
      const l = new THREE.Mesh(g,m); l.position.set(2.4,0.05,i);
      const r = l.clone(); r.position.x = -2.4;
      runway.add(l,r);
    }
    scene.add(runway);

    // starfield
    const starGeo = new THREE.BufferGeometry();
    const starCount = IS_MOBILE ? 800 : 1500;
    const starPos = new Float32Array(starCount*3);
    for (let i=0;i<starCount;i++){
      starPos[i*3+0] = (Math.random()-0.5)*120;
      starPos[i*3+1] = (Math.random()*40)+2;
      starPos[i*3+2] = -10 - Math.random()*260;
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPos,3));
    const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ size:0.26, color:0xbcd3ff, transparent:true, opacity:0.85 }));
    scene.add(stars);

    // label helper
    function makeLabel(text) {
      const c = document.createElement('canvas'), p=16, fs=34;
      const ctx = c.getContext('2d');
      ctx.font = `bold ${fs}px Inter, Arial`;
      const w = Math.ceil(ctx.measureText(text).width) + p*2;
      const h = fs + p*2;
      c.width = w; c.height = h;
      const c2 = c.getContext('2d');
      c2.font = `bold ${fs}px Inter, Arial`;
      c2.fillStyle='rgba(20,26,56,0.85)'; c2.strokeStyle='rgba(255,255,255,0.2)'; c2.lineWidth=4;
      c2.beginPath(); const r=18;
      c2.moveTo(r,0); c2.arcTo(w,0,w,h,r); c2.arcTo(w,h,0,h,r); c2.arcTo(0,h,0,0,r); c2.arcTo(0,0,w,0,r); c2.closePath();
      c2.fill(); c2.stroke();
      c2.fillStyle='#e6ebff'; c2.textAlign='center'; c2.textBaseline='middle';
      c2.fillText(text,w/2,h/2);
      const tex = new THREE.CanvasTexture(c);
      tex.minFilter = THREE.LinearFilter;
      const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent:true, depthWrite:false }));
      const s=0.008; spr.scale.set(w*s, h*s, 1); return spr;
    }

    class HelixCurve extends THREE.Curve {
      constructor(radius=0.5, height=1.2, turns=2){ super(); this.radius=radius; this.height=height; this.turns=turns; }
      getPoint(t){
        const ang = t * this.turns * Math.PI*2;
        const x = this.radius * Math.cos(ang);
        const z = this.radius * Math.sin(ang);
        const y = -this.height/2 + this.height * t;
        return new THREE.Vector3(x,y,z);
      }
    }

    function makeBumpyIcosa(radius=0.55, detail=1, noise=0.22){
      const geo = new THREE.IcosahedronGeometry(radius, detail);
      const pos = geo.getAttribute('position');
      for(let i=0;i<pos.count;i++){
        const v = new THREE.Vector3(pos.getX(i), pos.getY(i), pos.getZ(i)).normalize();
        const n = 1 + (Math.random()-0.5)*noise;
        v.multiplyScalar(radius * n);
        pos.setXYZ(i, v.x, v.y, v.z);
      }
      geo.computeVertexNormals();
      return geo;
    }

    // exhibits
    function addExhibit({ name, route, pos, type }) {
      const group = new THREE.Group();
      group.position.set(pos.x, pos.y, pos.z);

      if (type!=='wall') {
        const pedestal = new THREE.Mesh(
          new THREE.CylinderGeometry(0.65, 0.75, 0.5, 32),
          new THREE.MeshStandardMaterial({ color:0x121731, metalness:0.2, roughness:0.45 })
        );
        pedestal.receiveShadow = !IS_MOBILE;
        group.add(pedestal);
      }

      let mesh;
      switch(type){
        case 'planet': {
          mesh = new THREE.Mesh(
            new THREE.SphereGeometry(0.6, 48, 48),
            new THREE.MeshStandardMaterial({ color:0x8fb3ff, roughness:0.35, metalness:0.2 })
          );
        } break;

        case 'dish': {
          mesh = new THREE.Mesh(
            new THREE.SphereGeometry(0.7, 48, 48, 0, Math.PI*2, 0, Math.PI/2),
            new THREE.MeshStandardMaterial({ color:0xcad6ff, roughness:0.2, metalness:0.6 })
          );
          mesh.rotation.x = -Math.PI/6;
        } break;

        case 'statue': {
          mesh = new THREE.Mesh(
            new THREE.TorusKnotGeometry(0.42, 0.16, 128, 24),
            new THREE.MeshStandardMaterial({ color:0x9aaeff, metalness:0.65, roughness:0.25, emissive:0x1a2355, emissiveIntensity:0.25 })
          );
        } break;

        case 'pulsar': {
          mesh = new THREE.Group();
          const pulsarCore = new THREE.Mesh(
            new THREE.CylinderGeometry(0.18, 0.18, 1.2, 24),
            new THREE.MeshStandardMaterial({ color:0xbfd1ff, metalness:0.55, roughness:0.35, emissive:0x2840a0, emissiveIntensity:0.4 })
          );
          const tip1 = new THREE.Mesh(new THREE.ConeGeometry(0.22, 0.28, 24), new THREE.MeshStandardMaterial({ color:0xdfe7ff, metalness:0.6, roughness:0.2 }));
          const tip2 = tip1.clone(); tip1.position.y = 0.74; tip2.position.y = -0.74; tip2.rotation.x = Math.PI;
          mesh.add(pulsarCore, tip1, tip2);
        } break;

        case 'wall': {
          mesh = new THREE.Mesh(
            new THREE.PlaneGeometry(1.4, 1.8),
            new THREE.MeshStandardMaterial({ color:0x7aa7ff, metalness:0.4, roughness:0.15, emissive:0x2a3f88, emissiveIntensity:0.6 })
          );
          mesh.position.y = 1.35;
        } break;

        case 'array': {
          mesh = new THREE.Group();
          function dish(){
            const d = new THREE.Mesh(
              new THREE.SphereGeometry(0.45,40,40,0,Math.PI*2,0,Math.PI/2),
              new THREE.MeshStandardMaterial({ color:0xcad6ff, roughness:0.2, metalness:0.55 })
            );
            d.rotation.x = -Math.PI/5;
            const strut = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,0.5,12), new THREE.MeshStandardMaterial({ color:0x8aa2ff, roughness:0.4, metalness:0.4 }));
            strut.position.y = -0.55;
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.18,0.2,16), new THREE.MeshStandardMaterial({ color:0x121731, roughness:0.5, metalness:0.2 }));
            base.position.y = -0.75;
            const g = new THREE.Group(); g.add(d,strut,base); g.position.y = 1.0; return g;
          }
          const d1 = dish(); d1.position.x = -0.55;
          const d2 = dish(); d2.position.x =  0.55; d2.rotation.y =  0.4;
          const d3 = dish(); d3.position.z = -0.5; d3.rotation.y = -0.3;
          mesh.add(d1,d2,d3);
        } break;

        case 'prism': {
          mesh = new THREE.Mesh(
            new THREE.CylinderGeometry(0.55, 0.55, 1.0, 3),
            new THREE.MeshStandardMaterial({ color:0x9fd0ff, metalness:0.2, roughness:0.1, transparent:true, opacity:0.7 })
          );
        } break;

        case 'interf': {
          mesh = new THREE.Group();
          const t1 = new THREE.Mesh(new THREE.TorusGeometry(0.55, 0.06, 16, 100), new THREE.MeshStandardMaterial({ color:0xaad0ff, metalness:0.5, roughness:0.3 }));
          const t2 = new THREE.Mesh(new THREE.TorusGeometry(0.38, 0.05, 16, 100), new THREE.MeshStandardMaterial({ color:0x93b3ff, metalness:0.5, roughness:0.3 }));
          const t3 = new THREE.Mesh(new THREE.TorusGeometry(0.23, 0.04, 16, 100), new THREE.MeshStandardMaterial({ color:0x829fff, metalness:0.5, roughness:0.3 }));
          t2.rotation.x = Math.PI/2; t3.rotation.y = Math.PI/2;
          mesh.add(t1,t2,t3);
        } break;

        case 'nebula': {
          const g = new THREE.BufferGeometry();
          const n=600, a=new Float32Array(n*3);
          for(let i=0;i<n;i++){
            const r=Math.random()*0.9, th=Math.random()*Math.PI*2, ph=Math.acos(2*Math.random()-1);
            a[i*3]=r*Math.sin(ph)*Math.cos(th); a[i*3+1]=r*0.6*Math.cos(ph); a[i*3+2]=r*Math.sin(ph)*Math.sin(th);
          }
          g.setAttribute('position', new THREE.BufferAttribute(a,3));
          mesh = new THREE.Points(g, new THREE.PointsMaterial({ size:0.04, color:0xc7d7ff, transparent:true, opacity:0.9 }));
        } break;

        case 'binary': {
          mesh = new THREE.Group();
          const starA = new THREE.Mesh(new THREE.SphereGeometry(0.38, 36, 36), new THREE.MeshStandardMaterial({ color:0xffe7a1, emissive:0x442200, emissiveIntensity:0.2 }));
          const starB = new THREE.Mesh(new THREE.SphereGeometry(0.28, 36, 36), new THREE.MeshStandardMaterial({ color:0xaec9ff, emissive:0x112244, emissiveIntensity:0.25 }));
          starA.position.x = -0.5; starB.position.x = 0.6;
          mesh.add(starA,starB);
        } break;

        case 'lens': {
          mesh = new THREE.Group();
          const ring = new THREE.Mesh(new THREE.TorusGeometry(0.6, 0.08, 16, 120), new THREE.MeshStandardMaterial({ color:0xa3b8ff, metalness:0.6, roughness:0.25, emissive:0x1f2f66, emissiveIntensity:0.4 }));
          const inner = new THREE.Mesh(new THREE.RingGeometry(0.05, 0.48, 48), new THREE.MeshStandardMaterial({ color:0xdfe7ff, side:THREE.DoubleSide, transparent:true, opacity:0.35 }));
          inner.rotation.x = Math.PI/2; inner.position.y = 0.02;
          mesh.add(ring, inner);
        } break;

        case 'helix': {
          mesh = new THREE.Mesh(
            new THREE.TubeGeometry(new HelixCurve(0.45, 1.3, 3), 200, 0.07, 12, false),
            new THREE.MeshStandardMaterial({ color:0xffc38f, metalness:0.4, roughness:0.2, emissive:0x663311, emissiveIntensity:0.25 })
          );
        } break;

        case 'antenna': {
          mesh = new THREE.Group();
          const mast = new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.1,1.4,16), new THREE.MeshStandardMaterial({ color:0x9fb2ff, metalness:0.6, roughness:0.3 }));
          const dishSmall = new THREE.Mesh(new THREE.SphereGeometry(0.28, 32, 32, 0, Math.PI*2, 0, Math.PI/2), new THREE.MeshStandardMaterial({ color:0xcad6ff, metalness:0.55, roughness:0.25 }));
          dishSmall.position.set(0.25, 0.2, 0); dishSmall.rotation.x = -Math.PI/5;
          mast.position.y = 1.05;
          mesh.add(mast, dishSmall);
        } break;

        case 'satellite': {
          mesh = new THREE.Group();
          const satBody = new THREE.Mesh(new THREE.BoxGeometry(0.45,0.45,0.45), new THREE.MeshStandardMaterial({ color:0x9aaeff, metalness:0.7, roughness:0.25 }));
          const panel = new THREE.Mesh(new THREE.PlaneGeometry(0.9,0.28), new THREE.MeshStandardMaterial({ color:0x5f7cff, metalness:0.5, roughness:0.3, side:THREE.DoubleSide }));
          const p1 = panel.clone(); const p2 = panel.clone();
          p1.position.x = -0.7; p2.position.x = 0.7; p1.rotation.y = Math.PI/2; p2.rotation.y = Math.PI/2;
          const boom = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,0.6,10), new THREE.MeshStandardMaterial({ color:0x9aaeff }));
          boom.position.set(0,0.5,0);
          mesh.add(satBody,p1,p2,boom);
        } break;

        case 'meteor': {
          mesh = new THREE.Mesh(
            makeBumpyIcosa(0.6, 1, 0.35),
            new THREE.MeshStandardMaterial({ color:0x8089a8, roughness:0.9, metalness:0.1 })
          );
        } break;

        case 'datacube': {
          mesh = new THREE.Group();
          const box = new THREE.Mesh(new THREE.BoxGeometry(0.8,0.8,0.8), new THREE.MeshStandardMaterial({ color:0x1a2250, metalness:0.2, roughness:0.4, emissive:0x10142e, emissiveIntensity:0.3 }));
          const edges = new THREE.LineSegments(new THREE.EdgesGeometry(box.geometry), new THREE.LineBasicMaterial({ color:0x9db3ff }));
          mesh.add(box, edges);
        } break;

        /* ---- New custom artefacts ---- */
        case 'skadish': {
          // Single SKA dish with mount
          mesh = new THREE.Group();
          const d = new THREE.Mesh(
            new THREE.SphereGeometry(0.55, 48, 48, 0, Math.PI*2, 0, Math.PI/2),
            new THREE.MeshStandardMaterial({ color:0xcad6ff, roughness:0.22, metalness:0.65 })
          );
          d.rotation.x = -Math.PI/5;
          const arm = new THREE.Mesh(new THREE.CylinderGeometry(0.03,0.03,0.42, 16), new THREE.MeshStandardMaterial({ color:0x8aa2ff, metalness:0.5, roughness:0.35 }));
          arm.position.y = -0.48;
          const base = new THREE.Mesh(new THREE.CylinderGeometry(0.14,0.22,0.25, 24), new THREE.MeshStandardMaterial({ color:0x121731, roughness:0.5, metalness:0.2 }));
          base.position.y = -0.78;
          mesh.add(d, arm, base);
        } break;

        case 'skahq': {
          // SKA Headquarters: sleek stacked volumes with edge highlights
          mesh = new THREE.Group();
          const base = new THREE.Mesh(new THREE.BoxGeometry(1.8,0.6,1.0), new THREE.MeshStandardMaterial({ color:0x111834, roughness:0.55, metalness:0.2 }));
          base.position.y = 0.9;
          const tower = new THREE.Mesh(new THREE.BoxGeometry(1.2,0.8,0.8), new THREE.MeshStandardMaterial({ color:0x18224a, roughness:0.45, metalness:0.25 }));
          tower.position.y = 1.5;
          const dome = new THREE.Mesh(new THREE.SphereGeometry(0.18, 24, 24), new THREE.MeshStandardMaterial({ color:0x9fb7ff, roughness:0.2, metalness:0.6 }));
          dome.position.y = 2.05;
          const edges1 = new THREE.LineSegments(new THREE.EdgesGeometry(base.geometry), new THREE.LineBasicMaterial({ color:0x89a6ff }));
          edges1.position.copy(base.position);
          const edges2 = new THREE.LineSegments(new THREE.EdgesGeometry(tower.geometry), new THREE.LineBasicMaterial({ color:0xa7b9ff }));
          edges2.position.copy(tower.position);
          mesh.add(base, tower, dome, edges1, edges2);
        } break;

        case 'lab4d': {
          // 4D Laboratory: tesseract-like wireframe (two cubes + connectors)
          mesh = new THREE.Group();
          const outerSize = 0.9, innerSize = 0.55;
          const outer = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(outerSize, outerSize, outerSize)), new THREE.LineBasicMaterial({ color:0xc6d5ff }));
          const inner = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(innerSize, innerSize, innerSize)), new THREE.LineBasicMaterial({ color:0x8fb3ff }));
          mesh.add(outer, inner);
          // connectors between corresponding corners
          const conn = new THREE.BufferGeometry();
          const o = outerSize/2, i = innerSize/2;
          const corners = [
            [-1,-1,-1],[1,-1,-1],[-1,1,-1],[1,1,-1],
            [-1,-1, 1],[1,-1, 1],[-1,1, 1],[1,1, 1]
          ];
          const arr = new Float32Array(corners.length * 2 * 3);
          for (let k=0; k<corners.length; k++){
            const [sx,sy,sz] = corners[k];
            arr[k*6+0] = sx*i; arr[k*6+1] = sy*i; arr[k*6+2] = sz*i;
            arr[k*6+3] = sx*o; arr[k*6+4] = sy*o; arr[k*6+5] = sz*o;
          }
          conn.setAttribute('position', new THREE.BufferAttribute(arr,3));
          const lines = new THREE.LineSegments(conn, new THREE.LineBasicMaterial({ color:0x9db3ff }));
          mesh.add(lines);
        } break;

        default: {
          mesh = new THREE.Mesh(new THREE.ConeGeometry(0.5, 1.1, 6), new THREE.MeshStandardMaterial({ color:0xa59cff, roughness:0.25, metalness:0.5 }));
          mesh.position.y = 0.1;
        }
      }

      mesh.position.y = mesh.position.y || 0.95;
      mesh.castShadow = !IS_MOBILE;
      group.add(mesh);

      const label = makeLabel(name);
      label.position.set(0, 2.0, 0);
      group.add(label);

      // Per-exhibit spotlight: desktop only, no extra shadow maps
      if (!IS_MOBILE && type!=='nebula') {
        const spot = new THREE.SpotLight(0xffffff, 0.9, 10, Math.PI/6, 0.35, 1.8);
        spot.position.set(0.8, 3.5, 0.8);
        spot.target = mesh;
        spot.castShadow = false; // directional already provides shadows on desktop
        group.add(spot, spot.target);
      }

      group.userData = { route };
      group.children.forEach(ch => ch.userData = { route });
      scene.add(group);
      clickable.push(group);
      rotatables.push(group);
      return group;
    }

    // create exhibits
    addExhibit({ name:'Planetary Sculpture',    route:'#',    pos:{x:-3.2,y:0,z:-6},   type:'planet' });
    addExhibit({ name:'SKA Dish',               route:'dish.html',  pos:{x: 0.0,y:0,z:-12},  type:'skadish' });
    addExhibit({ name:'SKA Antenna',            route:'antenna.html',pos:{x: 3.2,y:0,z:-18}, type:'antenna' });
    addExhibit({ name:'SKA Headquarters',       route:'headquarter.html',    pos:{x:-3.2,y:0,z:-24},  type:'skahq' });
    addExhibit({ name:'4D Laboratory',          route:'4dmuseum.html',     pos:{x: 0.0,y:0,z:-30},  type:'lab4d' });
    addExhibit({ name:'Gravitational Lens',     route:'hypercube.html',      pos:{x: 3.2,y:0,z:-36},  type:'lens' });
    addExhibit({ name:'Meteorite Fragment',     route:'meteor.html',    pos:{x:-3.2,y:0,z:-42},  type:'meteor'  });
    addExhibit({ name:'Spectral Prism',         route:'prism.html',     pos:{x: 0.0,y:0,z:-48},  type:'prism'   });
    addExhibit({ name:'Wave Statue',            route:'wavestatue.html',    pos:{x: 3.2,y:0,z:-54},  type:'statue'  });

    // Picking helpers
    function setPointer(e){
      const rect = renderer.domElement.getBoundingClientRect();
      const cx = e.touches ? e.touches[0].clientX : e.clientX;
      const cy = e.touches ? e.touches[0].clientY : e.clientY;
      pointer.x = ((cx - rect.left) / rect.width) * 2 - 1;
      pointer.y = -((cy - rect.top) / rect.height) * 2 + 1;
    }

    function getRouteAtPointer(e){
      setPointer(e);
      raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects(clickable, true);
      if (!hits.length) return null;
      let o = hits[0].object;
      while (o && !o.userData.route) o = o.parent;
      return (o && o.userData.route) ? o.userData.route : null;
    }

    function navigateAtPointer(e){
      const route = getRouteAtPointer(e);
      if (route) location.href = route;
    }

    // Desktop: open link on double-click only
    renderer.domElement.addEventListener('dblclick', navigateAtPointer, { passive:true });

    // Mobile: open link on double-tap only
    let lastTapTime = 0, lastTapX=0, lastTapY=0;
    renderer.domElement.addEventListener('touchend', (e)=> {
      if (!e.changedTouches || e.changedTouches.length!==1) return;
      const touch = e.changedTouches[0];
      const now = performance.now();
      const dt = now - lastTapTime;
      const dx = touch.clientX - lastTapX;
      const dy = touch.clientY - lastTapY;
      lastTapTime = now; lastTapX = touch.clientX; lastTapY = touch.clientY;
      if (dt < 320 && (dx*dx+dy*dy) < (24*24)) {
        navigateAtPointer({ touches:[touch] });
      }
    }, { passive:true });

    // UI actions (elements are hidden but handlers retained for completeness)
    const ui = document.querySelector('.ui');
    const uiToggle = document.getElementById('uiToggle');
    uiToggle && uiToggle.addEventListener('click', () => {
      const hidden = document.body.classList.toggle('ui-hidden');
      uiToggle.setAttribute('aria-pressed', hidden ? 'true' : 'false');
      if (hidden) setTimeout(()=>{ if(ui) ui.style.display='none'; }, 220);
      else { if(ui) ui.style.display=''; }
    });

    document.getElementById('enterBtn')?.addEventListener('click', () => {
      const start = performance.now();
      const from = camera.position.clone();
      const toPos = new THREE.Vector3(0, 1.6, 8.5);
      const toLook= new THREE.Vector3(0, 1.3, -12);
      const fromLook = controls.target.clone();
      const ease = t => 1 - Math.pow(1 - t, 3);
      const step = now => {
        const t = Math.min(1, (now - start)/1600);
        const e = ease(t);
        camera.position.lerpVectors(from, toPos, e);
        controls.target.lerpVectors(fromLook, toLook, e);
        if (t<1) requestAnimationFrame(step);
      };
      requestAnimationFrame(step);
    });

    document.getElementById('exhibitsBtn')?.addEventListener('click', () => {
      location.href = 'exhibit.html?item=all';
    });

    document.getElementById('quickLinks')?.addEventListener('click', (e)=>{
      const btn = e.target.closest('button[data-link]');
      if (btn) location.href = btn.dataset.link;
    });

    document.getElementById('resetView')?.addEventListener('click', ()=>{
      const start = performance.now();
      const fromCam = camera.position.clone();
      const fromTgt = controls.target.clone();
      const toCam = new THREE.Vector3(0,1.6,12);
      const toTgt = new THREE.Vector3(0,1.3,-6);
      const ease = t => 1 - Math.pow(1 - t, 3);
      (function step(now){
        const t = Math.min(1, (now - start)/500);
        const e = ease(t);
        camera.position.lerpVectors(fromCam, toCam, e);
        controls.target.lerpVectors(fromTgt, toTgt, e);
        if (t<1) requestAnimationFrame(step);
      })(start);
    });

    document.getElementById('spinBtn')?.addEventListener('click', () => {
      spinning = !spinning;
    });

    // animate: slow uniform spin + optional corridor clamp
    const clock = new THREE.Clock();
    function animate(){
      const dt = clock.getDelta();
      controls.update();

      // gentle corridor clamp to keep target reasonable (helps zoom behavior)
      const t = controls.target;
      t.x = Math.max(-6, Math.min(6, t.x));
      t.y = Math.max(0.5, Math.min(3.5, t.y));
      t.z = Math.max(-150, Math.min(-4, t.z));

      if (spinning) {
        rotatables.forEach((g,i)=>{ g.rotation.y += (i%2?-1:1) * 0.08 * dt; });
      }
      stars.rotation.y += 0.02 * dt;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>
