<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Mormonism Museum — Virtual Gallery (VR)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#120a0a" />
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500;700&family=Inter:wght@300;500;700&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg:#0e0a12; --bg-2:#120a0a; --txt:#fffaf2; --muted:#d8c9c0; --glass:rgba(255,255,255,0.08); --glass-bd:rgba(255,255,255,0.18);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; color:var(--txt);
      background:
        radial-gradient(1200px 800px at 60% -20%, #3b1320 0%, transparent 60%),
        radial-gradient(1200px 800px at 40% 120%, #160e20 0%, transparent 60%),
        linear-gradient(180deg, #1a0f1a 0%, var(--bg-2) 60%);
      font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
      overflow:hidden;
    }
    #scene-wrap{position:fixed; inset:0}
    canvas{touch-action:none}

    /* UI panel */
    .panel{
      position:fixed; right:16px; top:16px; z-index:5;
      background:var(--glass); backdrop-filter: blur(10px);
      border:1px solid var(--glass-bd); border-radius:14px; padding:12px 14px; min-width:220px;
      box-shadow:0 6px 30px rgba(0,0,0,0.35);
    }
    .panel h3{font:700 14px Orbitron,Inter,sans-serif; letter-spacing:1.5px; margin:0 0 8px; color:#ffd27a}
    .row{display:flex; gap:10px; align-items:center; margin:8px 0}
    .btn{
      appearance:none; border:1px solid var(--glass-bd); background:rgba(255,255,255,0.06);
      color:var(--txt); border-radius:12px; font:600 13px Inter,system-ui; padding:8px 12px; cursor:pointer;
    }
    .hint{font-size:12px; color:var(--muted); margin-top:4px}

    /* Title (desktop only) */
    .title{ position:fixed; left:50%; top:24px; transform:translateX(-50%);
      font:700 16px Orbitron,Inter,sans-serif; letter-spacing:2px; text-transform:uppercase;
      color:var(--muted); opacity:0.9; z-index:4; display:none; }
    @media (min-width: 860px){ .title{display:block;} }
  </style>
</head>
<body>
  <div id="scene-wrap"></div>

  <div class="title">Mormonism — Virtual Gallery</div>

  <div class="panel" id="panel">
    <h3>VR</h3>
    <div class="row">
      <button class="btn" id="vrBtn">Enter VR</button>
    </div>
    <div class="hint">WebXR works in Chrome/Edge (Android) and Quest Browser.</div>
  </div>

  <script type="module">
    // Use your local module paths
    import * as THREE from '/three3.js';
    import { OrbitControls } from '/orbit.js';

    // --- Mobile detection
    const IS_MOBILE = /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i.test(navigator.userAgent) || (window.matchMedia && matchMedia('(pointer:coarse)').matches);

    // Core
    let scene, camera, renderer, controls, floor;
    const raycaster = new THREE.Raycaster();
    const pointer   = new THREE.Vector2();

    // Renderer
    const wrap = document.getElementById('scene-wrap');
    renderer = new THREE.WebGLRenderer({ antialias: !IS_MOBILE, alpha: true, powerPreference: 'high-performance' });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setPixelRatio(IS_MOBILE ? Math.min(devicePixelRatio, 1.5) : Math.min(devicePixelRatio, 2));
    renderer.shadowMap.enabled = !IS_MOBILE;
    if (!IS_MOBILE && THREE.PCFSoftShadowMap) renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    wrap.appendChild(renderer.domElement);
    renderer.domElement.style.touchAction = 'none';

    // === WebXR / VR ===
    renderer.xr.enabled = true;

    // Scene + camera + controls
    scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0c0710, 22, 160);

    camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 400);
    camera.position.set(0, 1.6, 12);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; controls.dampingFactor = 0.06;
    controls.enablePan = true; controls.screenSpacePanning = true;
    controls.rotateSpeed = 0.9; controls.zoomSpeed = 0.8; controls.panSpeed = 0.6;
    controls.minDistance = 1.2; controls.maxDistance = 80.0; controls.maxPolarAngle = Math.PI * 0.49;
    controls.target.set(0, 1.3, -6);
    if ('zoomToCursor' in controls) controls.zoomToCursor = true;

    // XR rig (for locomotion/teleport)
    const xrRig = new THREE.Group();
    scene.add(xrRig);
    xrRig.add(camera);

    // Toggle OrbitControls on XR start/end
    renderer.xr.addEventListener('sessionstart', ()=>{ controls.enabled = false; });
    renderer.xr.addEventListener('sessionend',   ()=>{ controls.enabled = true;  });

    addEventListener('resize', () => {
      camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    // Lights — warm palette
    scene.add(new THREE.AmbientLight(0xfff4e8, 0.26));
    const key = new THREE.DirectionalLight(0xffb088, 0.75); key.position.set(6, 10, 6); key.castShadow = !IS_MOBILE; key.shadow.mapSize.set(1024, 1024); scene.add(key);
    const hemi = new THREE.HemisphereLight(0xffc1a1, 0x130b17, IS_MOBILE ? 0.6 : 0.35); scene.add(hemi);
    const fill = new THREE.PointLight(0xffa070, 0.55, 60, 1.5); fill.position.set(-4, 4, -2); scene.add(fill);

    // Room
    const room = new THREE.Mesh(
      new THREE.BoxGeometry(22, 8, 100),
      new THREE.MeshStandardMaterial({ color:0x1a0d14, roughness:0.92, metalness:0.05, side:THREE.BackSide })
    );
    scene.add(room);

    floor = new THREE.Mesh(
      new THREE.PlaneGeometry(40, 160),
      new THREE.MeshStandardMaterial({ color:0x1a0f18, roughness:0.25, metalness:0.35 })
    );
    floor.rotation.x = -Math.PI/2; floor.receiveShadow = !IS_MOBILE; scene.add(floor);

    // Starfield (soft warm)
    const starGeo = new THREE.BufferGeometry();
    const starCount = IS_MOBILE ? 600 : 1100;
    const starPos = new Float32Array(starCount*3);
    for (let i=0;i<starCount;i++){
      starPos[i*3+0] = (Math.random()-0.5)*120;
      starPos[i*3+1] = (Math.random()*40)+2;
      starPos[i*3+2] = -10 - Math.random()*200;
    }
    starGeo.setAttribute('position', new THREE.BufferAttribute(starPos,3));
    const stars = new THREE.Points(starGeo, new THREE.PointsMaterial({ size:0.26, color:0xffe0bd, transparent:true, opacity:0.85 }));
    scene.add(stars);

    // Label helper
    function makeLabel(text) {
      const c = document.createElement('canvas'), p=16, fs=34;
      const ctx = c.getContext('2d');
      ctx.font = `bold ${fs}px Inter, Arial`;
      const w = Math.ceil(ctx.measureText(text).width) + p*2; const h = fs + p*2;
      c.width = w; c.height = h; const c2 = c.getContext('2d'); c2.font = `bold ${fs}px Inter, Arial`;
      c2.fillStyle='rgba(24,12,20,0.85)'; c2.strokeStyle='rgba(255,255,255,0.25)'; c2.lineWidth=4;
      c2.beginPath(); const r=18; c2.moveTo(r,0); c2.arcTo(w,0,w,h,r); c2.arcTo(w,h,0,h,r); c2.arcTo(0,h,0,0,r); c2.arcTo(0,0,w,0,r); c2.closePath();
      c2.fill(); c2.stroke();
      c2.fillStyle='#fff6e9'; c2.textAlign='center'; c2.textBaseline='middle'; c2.fillText(text,w/2,h/2);
      const tex = new THREE.CanvasTexture(c); tex.minFilter = THREE.LinearFilter;
      const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent:true, depthWrite:false }));
      const s=0.008; spr.scale.set(w*s, h*s, 1); return spr;
    }

    // Description helper (smaller under‑label text)
    function makeSub(text){
      const c = document.createElement('canvas'), p=12, fs=22; const ctx = c.getContext('2d');
      ctx.font = `600 ${fs}px Inter, Arial`; const w = Math.ceil(ctx.measureText(text).width) + p*2; const h = fs + p*2; c.width = w; c.height = h;
      const g = c.getContext('2d'); g.font = `600 ${fs}px Inter, Arial`; g.fillStyle='rgba(255,255,255,0.75)'; g.textAlign='center'; g.textBaseline='middle'; g.fillText(text,w/2,h/2);
      const tex = new THREE.CanvasTexture(c); tex.minFilter = THREE.LinearFilter;
      const spr = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, transparent:true, depthWrite:false }));
      const s=0.006; spr.scale.set(w*s, h*s, 1); return spr;
    }

    // Pedestal
    function makePedestal(){
      const p = new THREE.Mesh(
        new THREE.CylinderGeometry(0.65, 0.75, 0.5, 32),
        new THREE.MeshStandardMaterial({ color:0x26131c, metalness:0.25, roughness:0.45 })
      );
      p.receiveShadow = !IS_MOBILE; return p;
    }

    // Exhibit builder
    function addExhibit({ name, sub, pos = {x:0,y:0,z:0}, buildMesh } = {}) {
      const group = new THREE.Group();
      const p = (pos && typeof pos.x==='number' && typeof pos.y==='number' && typeof pos.z==='number') ? pos : {x:0,y:0,z:0};
      group.position.set(p.x, p.y, p.z);
      const pedestal = makePedestal(); group.add(pedestal);
      const builder = (typeof buildMesh === 'function') ? buildMesh : ()=> new THREE.Group();
      let mesh = builder();
      if (!mesh || !(mesh && mesh.isObject3D)) { console.warn('[addExhibit] buildMesh did not return an Object3D for', name); mesh = new THREE.Group(); }
      if (mesh.position && typeof mesh.position.y === 'number') { mesh.position.y = 0.95; }
      if (mesh.castShadow !== undefined) mesh.castShadow = !IS_MOBILE; group.add(mesh);
      const label = makeLabel(name); label.position.set(0, 2.0, 0); group.add(label);
      if (sub){ const l2 = makeSub(sub); l2.position.set(0, 1.7, 0); group.add(l2); }
      if (!IS_MOBILE) { const spot = new THREE.SpotLight(0xffffff, 0.9, 10, Math.PI/6, 0.35, 1.8); spot.position.set(0.8, 3.5, 0.8); spot.target = mesh; group.add(spot, spot.target); }
      scene.add(group); return group;
    }

    // --- Artifacts (Mormonism) ---
    // 1) Golden Plates (Book of Mormon)
    function buildPlates(){
      const geom = new THREE.BoxGeometry(0.2, 0.25, 0.1);
      const mat = new THREE.MeshStandardMaterial({ color:0xffd27a, metalness:0.8, roughness:0.3 });
      const mesh = new THREE.Mesh(geom, mat);
      mesh.userData.update = (t)=> { mesh.rotation.y += 0.1 * clock.getDelta(); };
      return mesh;
    }

    // 2) Liahona (Divine Compass)
    function buildLiahona(){
      const group = new THREE.Group();
      // outer sphere (brass)
      const sphereGeom = new THREE.SphereGeometry(0.25, 24, 18);
      const sphereMat = new THREE.MeshStandardMaterial({ color:0xffc040, metalness:0.5, roughness:0.3, transparent:true, opacity:0.6 });
      const sphere = new THREE.Mesh(sphereGeom, sphereMat);
      group.add(sphere);
      // internal pointers (two perpendicular rods)
      const pointerGroup = new THREE.Group();
      const rodGeom = new THREE.CylinderGeometry(0.01, 0.01, 0.6, 8);
      const rodMat = new THREE.MeshStandardMaterial({ color:0xffffff, metalness:0.1, roughness:0.5 });
      const rod1 = new THREE.Mesh(rodGeom, rodMat);
      rod1.rotateZ(Math.PI/2);
      const rod2 = rod1.clone();
      rod2.rotateX(Math.PI/2);
      pointerGroup.add(rod1, rod2);
      group.add(pointerGroup);
      // animate pointers rotating
      pointerGroup.userData.update = (t)=> { pointerGroup.rotation.y += 0.3 * clock.getDelta(); };
      return group;
    }

    // 3) Tree of Life (Lehi's Vision)
    function buildTree(){
      const group = new THREE.Group();
      // trunk
      const trunkGeom = new THREE.CylinderGeometry(0.05, 0.05, 0.8, 12);
      const trunkMat = new THREE.MeshStandardMaterial({ color:0x8b5a2b, metalness:0.2, roughness:0.8 });
      const trunk = new THREE.Mesh(trunkGeom, trunkMat);
      trunk.position.y = 0.4;
      group.add(trunk);
      // glowing canopy (clusters of white spheres)
      const canopyMat = new THREE.MeshStandardMaterial({ color:0xffffff, emissive:0xffffff, emissiveIntensity:0.7, roughness:0.4 });
      const sphereMain = new THREE.Mesh(new THREE.SphereGeometry(0.2, 16, 12), canopyMat);
      sphereMain.position.y = 0.8;
      group.add(sphereMain);
      const sphere1 = new THREE.Mesh(new THREE.SphereGeometry(0.15, 12, 10), canopyMat);
      sphere1.position.set(0.2, 0.75, 0);
      const sphere2 = sphere1.clone();
      sphere2.position.set(-0.2, 0.75, 0);
      const sphere3 = sphere1.clone();
      sphere3.position.set(0, 0.7, 0.2);
      const sphere4 = sphere1.clone();
      sphere4.position.set(0, 0.7, -0.2);
      group.add(sphere1, sphere2, sphere3, sphere4);
      return group;
    }

    // 4) Ten Commandments (Tablets of Law)
    function buildTablets(){
      const group = new THREE.Group();
      const w = 0.4, h = 0.5, r = 0.2;
      const shape = new THREE.Shape();
      shape.moveTo(-w/2, 0);
      shape.lineTo(-w/2, h - r);
      shape.absarc(0, h - r, r, Math.PI, 0, false);
      shape.lineTo(w/2, 0);
      shape.closePath();
      const extrudeSettings = { depth: 0.04, bevelEnabled: false };
      const tabletGeom = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      const tabletMat = new THREE.MeshStandardMaterial({ color:0xbbbbbb, metalness:0.1, roughness:0.9 });
      const tablet1 = new THREE.Mesh(tabletGeom, tabletMat);
      const tablet2 = tablet1.clone();
      // tilt slightly open
      tablet1.rotateY(Math.PI + 0.1);
      tablet2.rotateY(Math.PI - 0.1);
      tablet1.position.x = -0.22;
      tablet2.position.x = 0.22;
      group.add(tablet1, tablet2);
      return group;
    }

    // 5) Salt Lake Temple (Sacred Temple)
    function buildTemple(){
      const group = new THREE.Group();
      const mat = new THREE.MeshStandardMaterial({ color:0xdddddd, metalness:0.2, roughness:0.8 });
      // base building
      const base = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.2, 0.2), mat);
      base.position.y = 0.1;
      base.position.z = -0.1;
      group.add(base);
      // towers
      const leftTower = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.7, 0.1), mat);
      const rightTower = leftTower.clone();
      const centerTower = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.9, 0.1), mat);
      leftTower.position.set(-0.2, 0.2 + 0.35, 0);
      rightTower.position.set(0.2, 0.2 + 0.35, 0);
      centerTower.position.set(0, 0.2 + 0.45, 0);
      group.add(leftTower, rightTower, centerTower);
      // mid connector wall
      const mid = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.1, 0.1), mat);
      mid.position.set(0, 0.5, -0.05);
      group.add(mid);
      // spires
      const leftSpire = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.2, 8), mat);
      const rightSpire = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.2, 8), mat);
      const centerSpire = new THREE.Mesh(new THREE.ConeGeometry(0.05, 0.3, 8), mat);
      leftSpire.position.set(-0.2, 0.9 + 0.1, 0);
      rightSpire.position.set(0.2, 0.9 + 0.1, 0);
      centerSpire.position.set(0, 1.1 + 0.15, 0);
      group.add(leftSpire, rightSpire, centerSpire);
      // rotate slowly for full view
      group.userData.update = (t)=> { group.rotation.y += 0.05 * clock.getDelta(); };
      return group;
    }

    // 6) Angel Moroni (Trumpeting Angel)
    function buildMoroni(){
      const group = new THREE.Group();
      const mat = new THREE.MeshStandardMaterial({ color:0xffd700, metalness:0.8, roughness:0.3 });
      // body
      const body = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.6, 12), mat);
      body.position.y = 0.3;
      group.add(body);
      // head
      const head = new THREE.Mesh(new THREE.SphereGeometry(0.08, 12, 12), mat);
      head.position.y = 0.68;
      group.add(head);
      // trumpet
      const trumpet = new THREE.Mesh(new THREE.CylinderGeometry(0.005, 0.02, 0.4, 8), mat);
      trumpet.rotateX(-Math.PI/4);
      trumpet.position.set(0, 0.82, 0.14);
      group.add(trumpet);
      // slowly rotate
      group.userData.update = (t)=> { group.rotation.y += 0.1 * clock.getDelta(); };
      return group;
    }

    // 7) Beehive (Industry Symbol)
    function buildBeehive(){
      const group = new THREE.Group();
      const mat = new THREE.MeshStandardMaterial({ color:0xdeb887, metalness:0.2, roughness:0.9 });
      // stacked rings
      const ring1 = new THREE.Mesh(new THREE.TorusGeometry(0.25, 0.06, 16, 32), mat);
      ring1.position.y = 0.06;
      const ring2 = new THREE.Mesh(new THREE.TorusGeometry(0.2, 0.05, 16, 32), mat);
      ring2.position.y = 0.16;
      const ring3 = new THREE.Mesh(new THREE.TorusGeometry(0.15, 0.04, 16, 32), mat);
      ring3.position.y = 0.25;
      const ring4 = new THREE.Mesh(new THREE.TorusGeometry(0.1, 0.03, 16, 32), mat);
      ring4.position.y = 0.33;
      group.add(ring1, ring2, ring3, ring4);
      // dome cap
      const cap = new THREE.Mesh(new THREE.SphereGeometry(0.08, 12, 12), mat);
      cap.position.y = 0.45;
      group.add(cap);
      // entrance hole
      const hole = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.01, 8), new THREE.MeshStandardMaterial({ color:0x000000, roughness:0.9, metalness:0 }));
      hole.rotateX(Math.PI/2);
      hole.position.set(0, 0.1, -0.25);
      group.add(hole);
      return group;
    }

    // Place exhibits
    const exPlates = addExhibit({ name:'Golden Plates', sub:'Book of Mormon', pos:{x:-7.0,y:0,z:-10}, buildMesh: buildPlates });
    const exLiah   = addExhibit({ name:'Liahona', sub:'Divine Compass', pos:{x:-3.5,y:0,z:-12}, buildMesh: buildLiahona });
    const exTree   = addExhibit({ name:'Tree of Life', sub:'Lehi\'s Vision', pos:{x: 0.0,y:0,z:-14}, buildMesh: buildTree });
    const exTabs   = addExhibit({ name:'Ten Commandments', sub:'Tablets of Law', pos:{x: 3.5,y:0,z:-12}, buildMesh: buildTablets });
    const exTemple = addExhibit({ name:'Salt Lake Temple', sub:'Sacred Temple', pos:{x:-3.0,y:0,z:-22}, buildMesh: buildTemple });
    const exMoroni = addExhibit({ name:'Angel Moroni', sub:'Trumpeting Angel', pos:{x: 3.0,y:0,z:-22}, buildMesh: buildMoroni });
    const exBee    = addExhibit({ name:'Beehive', sub:'Industry Symbol', pos:{x: 7.0,y:0,z:-10}, buildMesh: buildBeehive });

    // ===== VR Helpers =====
    // Controller + laser pointer
    const controller = renderer.xr.getController(0);
    xrRig.add(controller);
    const controllerGeo = new THREE.BufferGeometry().setFromPoints([ new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-1) ]);
    const controllerRay = new THREE.Line(controllerGeo, new THREE.LineBasicMaterial({ transparent:true, opacity:0.9 }));
    controllerRay.name = 'controllerRay'; controllerRay.scale.z = 10; controller.add(controllerRay);

    // Reticle for teleport target
    const reticle = new THREE.Mesh(
      new THREE.RingGeometry(0.15, 0.17, 32),
      new THREE.MeshBasicMaterial({ transparent:true, opacity:0.85, side:THREE.DoubleSide })
    );
    reticle.rotation.x = -Math.PI/2; reticle.visible = false; scene.add(reticle);

    const tempMatrix = new THREE.Matrix4();
    function intersectController(ctrl, objects){
      tempMatrix.identity().extractRotation(ctrl.matrixWorld);
      raycaster.ray.origin.setFromMatrixPosition(ctrl.matrixWorld);
      raycaster.ray.direction.set(0,0,-1).applyMatrix4(tempMatrix);
      const hits = raycaster.intersectObjects(objects, true);
      return hits[0] || null;
    }

    function tryTeleport(){
      if (!renderer.xr.isPresenting) return;
      const hit = intersectController(controller, [floor]);
      if (hit){ xrRig.position.set(hit.point.x, 0, hit.point.z); }
    }

    controller.addEventListener('select', tryTeleport);

    // --- Refocus at pointer (dblclick / double‑tap for non‑VR)
    function setPointer(e){
      const rect = renderer.domElement.getBoundingClientRect(); const cx = e.touches ? e.touches[0].clientX : e.clientX; const cy = e.touches ? e.touches[0].clientY : e.clientY;
      pointer.x = ((cx - rect.left) / rect.width) * 2 - 1; pointer.y = -((cy - rect.top) / rect.height) * 2 + 1;
    }
    function focusAtPointer(e){
      setPointer(e); raycaster.setFromCamera(pointer, camera);
      const hits = raycaster.intersectObjects([exPlates, exLiah, exTree, exTabs, exTemple, exMoroni, exBee, floor], true);
      if (!hits.length) return; const p = hits[0].point; const dist = camera.position.distanceTo(controls.target); const dir = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
      const newCamPos = new THREE.Vector3().copy(p).addScaledVector(dir, dist);
      const start = performance.now(); const fromCam = camera.position.clone(); const fromTgt = controls.target.clone(); const ease = t => 1 - Math.pow(1 - t, 3);
      (function step(now){ const t = Math.min(1, (now - start) / 420); const e2 = ease(t); camera.position.lerpVectors(fromCam, newCamPos, e2); controls.target.lerpVectors(fromTgt, p, e2); if (t < 1) requestAnimationFrame(step); })(start);
    }
    renderer.domElement.addEventListener('dblclick', focusAtPointer, { passive:true });
    let lastTapTime = 0, lastTapX=0, lastTapY=0; renderer.domElement.addEventListener('touchend', (e)=>{
      if (!e.changedTouches || e.changedTouches.length!==1) return; const touch = e.changedTouches[0]; const now = performance.now();
      const dt = now - lastTapTime; const dx = touch.clientX - lastTapX; const dy = touch.clientY - lastTapY; lastTapTime = now; lastTapX = touch.clientX; lastTapY = touch.clientY;
      if (dt < 320 && (dx*dx+dy*dy) < (24*24)) focusAtPointer({ touches:[touch] });
    }, { passive:true });

    // Animation clock
    const clock = new THREE.Clock();

    function renderLoop(){
      const t = clock.getElapsedTime();
      controls.update();

      // keep target reasonable
      const tgt = controls.target; tgt.x = Math.max(-8, Math.min(8, tgt.x)); tgt.y = Math.max(0.5, Math.min(3.5, tgt.y)); tgt.z = Math.max(-120, Math.min(-4, tgt.z));

      // per-exhibit updates
      [exPlates, exLiah, exTree, exTabs, exTemple, exMoroni, exBee].forEach(g=>{
        const m = g.children.find(o=>o.userData && o.userData.update);
        if (m && m.userData.update) m.userData.update(t);
        if (g.userData.update) g.userData.update(t);
      });

      // gentle ambient motion
      // (rotate stars background)
      stars.rotation.y += 0.02 * clock.getDelta();

      // VR reticle update
      if (renderer.xr.isPresenting){
        const hit = intersectController(controller, [floor]);
        if (hit){ reticle.position.copy(hit.point); reticle.visible = true; } else { reticle.visible = false; }
      } else { reticle.visible = false; }

      renderer.render(scene, camera);
    }
    renderer.setAnimationLoop(renderLoop);

    // UI: Single VR button
    const vrBtn = document.getElementById('vrBtn');
    let currentSession = null;
    if (vrBtn){
      vrBtn.addEventListener('click', async ()=>{
        if (!('xr' in navigator)){
          alert('WebXR not supported on this device/browser. Try Chrome on Android or the Quest Browser.');
          return;
        }
        if (!currentSession){
          try {
            const session = await navigator.xr.requestSession('immersive-vr', { requiredFeatures: ['local-floor'] });
            currentSession = session;
            session.addEventListener('end', ()=>{ currentSession = null; vrBtn.textContent = 'Enter VR'; });
            await renderer.xr.setSession(session);
            vrBtn.textContent = 'Exit VR';
          } catch (e) {
            console.warn('VR start failed:', e);
            alert('Unable to start VR: ' + (e?.message ?? e));
          }
        } else { currentSession.end(); }
      });
    }
  </script>
</body>
</html>

