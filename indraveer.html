<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Indraveer Typing Practice</title>
  <style>
    :root{
      --bg1:#0b1020;
      --bg2:#101a3a;
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.70);
      --muted2:rgba(255,255,255,.55);
      --good:#3ddc97;
      --bad:#ff5a7a;
      --stroke:rgba(255,255,255,.12);
      --stroke2:rgba(255,255,255,.18);
      --shadow: 0 18px 60px rgba(0,0,0,.40);
      --radius: 20px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 600px at 15% 10%, rgba(124, 92, 255, .30), transparent 60%),
        radial-gradient(900px 500px at 85% 20%, rgba(0, 212, 255, .20), transparent 55%),
        radial-gradient(800px 500px at 50% 90%, rgba(61, 220, 151, .16), transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      overflow-x:hidden;
    }

    .app{ max-width: 1180px; margin: 0 auto; padding: 28px 16px 42px; }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 14px;
      margin-bottom: 18px;
    }

    .brand{ display:flex; align-items:center; gap: 12px; user-select:none; }
    .logo{
      width: 42px; height: 42px;
      border-radius: 14px;
      background: linear-gradient(135deg, rgba(124, 92, 255, .9), rgba(0, 212, 255, .6));
      box-shadow: 0 10px 30px rgba(124,92,255,.18);
      position: relative;
      overflow:hidden;
    }
    .logo:before{
      content:"";
      position:absolute; inset:-30%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.55), transparent 55%);
      transform: rotate(18deg);
    }

    h1{ font-size: 18px; line-height: 1.2; margin: 0; letter-spacing:.2px; }
    .subtitle{ margin: 3px 0 0; font-size: 12.5px; color: var(--muted); }

    .header-actions{ display:flex; align-items:center; gap: 10px; flex-wrap:wrap; justify-content:flex-end; }

    .btn{
      appearance:none;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.05);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      cursor:pointer;
      font-weight: 650;
      font-size: 13px;
      letter-spacing:.15px;
      box-shadow: 0 10px 26px rgba(0,0,0,.18);
      transition: transform .12s ease, border-color .12s ease, background .12s ease;
      white-space:nowrap;
    }
    .btn:hover{ transform: translateY(-1px); border-color: var(--stroke2); background: rgba(255,255,255,.07); }
    .btn:active{ transform: translateY(0px); }
    .btn.primary{ border-color: rgba(61,220,151,.35); background: rgba(61,220,151,.12); }
    .btn.danger{ border-color: rgba(255,90,122,.38); background: rgba(255,90,122,.10); }
    .btn:disabled{ cursor:not-allowed; opacity:.55; transform:none; }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.05);
      border: 1px solid var(--stroke);
      color: var(--muted);
      font-size: 12.5px;
      user-select:none;
    }

    main{ display:grid; grid-template-columns: 300px 1fr 340px; gap: 14px; }
    @media (max-width: 1040px){ main{ grid-template-columns: 1fr; } }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.04));
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .card .card-h{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      padding: 14px 16px;
      border-bottom: 1px solid var(--stroke);
      background: rgba(0,0,0,.12);
    }

    .card .card-h .title{
      margin:0;
      font-size: 13.5px;
      letter-spacing:.25px;
      color: rgba(255,255,255,.86);
      font-weight: 750;
      text-transform: uppercase;
    }

    .card .card-b{ padding: 14px 16px 16px; }

    .rule{ display:flex; gap: 10px; margin: 10px 0; color: var(--muted); font-size: 13px; line-height: 1.35; }
    .dot{ flex: 0 0 auto; width: 10px; height: 10px; border-radius: 50%; margin-top: 4px; background: rgba(255,255,255,.18); border: 1px solid rgba(255,255,255,.22); }
    .dot.good{ background: rgba(61,220,151,.22); border-color: rgba(61,220,151,.35); }
    .dot.bad{ background: rgba(255,90,122,.18); border-color: rgba(255,90,122,.35); }

    .kbdgrid{ display:grid; grid-template-columns: repeat(10, minmax(0, 1fr)); gap: 6px; margin-top: 10px; }
    .key{
      font-family: var(--mono);
      font-size: 12.5px;
      padding: 7px 0;
      border-radius: 12px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.10);
      text-align:center;
      color: rgba(255,255,255,.82);
      user-select:none;
    }

    .progress{
      height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      overflow:hidden;
    }
    .progress > div{
      height:100%;
      width:0%;
      background: linear-gradient(90deg, rgba(124,92,255,.75), rgba(0,212,255,.65), rgba(61,220,151,.65));
      border-radius:999px;
      transition: width .18s ease;
    }

    .target{
      height: 260px;
      padding: 14px 16px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      overflow:auto;
      font-family: var(--mono);
      line-height: 1.6;
      font-size: 14px;
      letter-spacing: .15px;
      scroll-behavior:smooth;
    }

    .target .c{ white-space: pre-wrap; }
    .target .c.correct{ color: rgba(61,220,151,.92); }
    .target .c.incorrect{
      color: rgba(255,90,122,.95);
      text-decoration: underline;
      text-decoration-thickness: 2px;
      text-underline-offset: 3px;
    }
    .target .c.cursor{
      background: rgba(255,255,255,.16);
      border-radius: 3px;
      outline: 1px solid rgba(255,255,255,.18);
    }

    .typebox{
      width:100%;
      min-height: 170px;
      padding: 14px 16px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      color: var(--text);
      font-family: var(--mono);
      font-size: 15px;
      line-height: 1.55;
      resize: vertical;
      outline: none;
      box-shadow: 0 14px 40px rgba(0,0,0,.25);
    }
    .typebox:focus{ border-color: rgba(0,212,255,.35); }

    .hint{
      margin-top: 10px;
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
      align-items:center;
      justify-content:space-between;
      color: var(--muted2);
      font-size: 12.5px;
    }

    .toast{
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      background: rgba(0,0,0,.65);
      border: 1px solid rgba(255,255,255,.16);
      color: rgba(255,255,255,.92);
      padding: 10px 12px;
      border-radius: 999px;
      font-size: 13px;
      box-shadow: 0 14px 50px rgba(0,0,0,.45);
      opacity: 0;
      pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
      z-index: 999;
      max-width: min(92vw, 720px);
      text-align:center;
    }
    .toast.show{ opacity: 1; transform: translateX(-50%) translateY(-2px); }

    .statgrid{ display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .stat{
      padding: 12px 12px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.14);
    }
    .stat .k{ font-size: 12px; color: var(--muted); letter-spacing:.2px; margin:0 0 6px; }
    .stat .v{ margin:0; font-size: 20px; font-weight: 800; letter-spacing:.2px; }
    .stat .sub{ margin-top: 6px; font-size: 12.5px; color: var(--muted2); line-height:1.25; }

    .big{ grid-column: 1 / -1; display:flex; align-items:flex-end; justify-content:space-between; gap: 10px; }
    .timer{ font-family: var(--mono); font-size: 28px; font-weight: 900; letter-spacing: .8px; margin:0; }
    .status{ display:flex; flex-wrap:wrap; gap: 8px; justify-content:flex-end; }

    .divider{ margin: 14px 0 0; padding-top: 14px; border-top: 1px solid rgba(255,255,255,.10); }

    .history-top{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap: 12px;
      flex-wrap:wrap;
      margin-bottom: 10px;
    }

    .mini{
      display:flex;
      gap: 10px;
      flex-wrap:wrap;
      align-items:center;
      color: var(--muted2);
      font-size: 12.5px;
      line-height: 1.25;
    }
    .mini strong{ color: rgba(255,255,255,.92); }

    .history-actions{ display:flex; gap: 8px; flex-wrap:wrap; justify-content:flex-end; }

    .tablewrap{
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      background: rgba(0,0,0,.12);
      overflow:hidden;
    }
    table{
      width:100%;
      border-collapse: collapse;
      font-size: 12.5px;
    }
    thead th{
      text-align:left;
      padding: 10px 10px;
      background: rgba(255,255,255,.04);
      border-bottom: 1px solid rgba(255,255,255,.10);
      color: rgba(255,255,255,.80);
      font-weight: 750;
      letter-spacing:.15px;
      white-space:nowrap;
    }
    tbody td{
      padding: 9px 10px;
      border-bottom: 1px solid rgba(255,255,255,.07);
      color: rgba(255,255,255,.86);
      white-space:nowrap;
    }
    tbody tr:last-child td{ border-bottom:none; }
    tbody td.muted{ color: var(--muted2); }
    .scroll{
      max-height: 260px;
      overflow:auto;
    }

    .spark{
      display:flex;
      align-items:flex-end;
      gap: 6px;
      height: 60px;
      padding: 10px 10px 12px;
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      background: rgba(0,0,0,.12);
      margin-bottom: 10px;
      overflow:hidden;
    }
    .bar{
      width: 10px;
      border-radius: 999px;
      background: rgba(0, 212, 255, .35);
      outline: 1px solid rgba(255,255,255,.08);
      flex: 0 0 auto;
    }
    .bar.best{
      background: rgba(61, 220, 151, .38);
      outline-color: rgba(61, 220, 151, .22);
    }
    .barlabel{
      font-size: 11px;
      color: var(--muted2);
      text-align:center;
      margin-top: 6px;
    }

    .modal{ position: fixed; inset: 0; display:none; place-items:center; background: rgba(0,0,0,.55); z-index: 1000; padding: 18px; }
    .modal.show{ display:grid; }
    .modal-card{
      width: min(780px, 100%);
      border-radius: 24px;
      border: 1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      box-shadow: 0 30px 90px rgba(0,0,0,.55);
      overflow:hidden;
    }
    .modal-h{
      padding: 16px 18px;
      border-bottom: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.16);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }
    .modal-h h2{ margin:0; font-size: 16px; letter-spacing:.2px; }
    .modal-b{ padding: 16px 18px 18px; }
    .resultline{ display:flex; justify-content:space-between; gap: 14px; padding: 10px 0; border-bottom: 1px solid rgba(255,255,255,.08); color: var(--muted); font-size: 13.5px; }
    .resultline:last-child{ border-bottom:none; }
    .resultline strong{ color: rgba(255,255,255,.92); }
    .note{ margin-top: 12px; color: var(--muted2); font-size: 12.5px; line-height: 1.35; }

    .sr-only{ position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1>Indraveer Typing Practice</h1>
          <p class="subtitle">No-backspace typing test • plain English with normal punctuation</p>
        </div>
      </div>
      <div class="header-actions">
        <span class="pill" title="Backspace and Delete are disabled during the test.">⌫ Backspace: <strong style="color:rgba(255,255,255,.92)">Not allowed</strong></span>
        <button id="btnNew" class="btn" type="button">New text</button>
        <button id="btnStart" class="btn primary" type="button">Start test</button>
        <button id="btnReset" class="btn danger" type="button" disabled>Reset</button>
      </div>
    </header>

    <main>
      <!-- Left -->
      <section class="card">
        <div class="card-h">
          <p class="title">Rules & Characters</p>
        </div>
        <div class="card-b">
          <div class="rule"><span class="dot good"></span><span>Timer runs for ten minutes. Results lock when time ends.</span></div>
          <div class="rule"><span class="dot bad"></span><span>Backspace and Delete are blocked for strict practice.</span></div>
          <div class="rule"><span class="dot"></span><span>Typing is sequential (cursor is forced to the end).</span></div>
          <div class="rule"><span class="dot"></span><span>Paste and undo are disabled to keep the score genuine.</span></div>

          <div style="margin-top:14px; color:var(--muted); font-size:13px;">Characters used in the target text:</div>
          <div id="kbd" class="kbdgrid" aria-label="Character set"></div>
        </div>
      </section>

      <!-- Center -->
      <section class="card">
        <div class="card-h">
          <p class="title">Target Text</p>
          <div style="display:flex; gap:10px; align-items:center; color:var(--muted); font-size:12.5px;">
            <span id="lenInfo">Length: —</span>
          </div>
        </div>
        <div class="card-b" style="display:flex; flex-direction:column; gap:12px;">
          <div class="progress" aria-label="time progress"><div id="prog"></div></div>
          <div id="target" class="target" aria-label="Target text area"></div>
          <div>
            <label class="sr-only" for="typebox">Typing input</label>
            <textarea id="typebox" class="typebox" placeholder="Press Start, then type the target text here…" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off" disabled></textarea>
            <div class="hint">
              <span>Tip: Type continuously. Do not stop to correct mistakes.</span>
              <span id="liveWarn" aria-live="polite"></span>
            </div>
          </div>
        </div>
      </section>

      <!-- Right -->
      <section class="card">
        <div class="card-h">
          <p class="title">Stats & History</p>
        </div>
        <div class="card-b">
          <div class="statgrid">
            <div class="stat big">
              <div>
                <p class="k">Time left</p>
                <p id="timer" class="timer">10:00</p>
              </div>
              <div class="status">
                <span id="statePill" class="pill">Status: <strong style="color:rgba(255,255,255,.92)">Ready</strong></span>
              </div>
            </div>

            <div class="stat">
              <p class="k">Gross WPM</p>
              <p id="grossWpm" class="v">0</p>
              <div class="sub">total characters ÷ five ÷ minutes</div>
            </div>

            <div class="stat">
              <p class="k">Net speed (exam)</p>
              <p id="netWpm" class="v">0</p>
              <div class="sub">allowable errors rule</div>
            </div>

            <div class="stat">
              <p class="k">Accuracy</p>
              <p id="acc" class="v">100%</p>
              <div class="sub">correct characters ÷ typed</div>
            </div>

            <div class="stat">
              <p class="k">Total errors</p>
              <p id="err" class="v">0</p>
              <div class="sub">incorrect characters</div>
            </div>

            <div class="stat">
              <p class="k">Allowable errors</p>
              <p id="allowErr" class="v">0</p>
              <div class="sub">five percent of total words</div>
            </div>

            <div class="stat">
              <p class="k">Final mistakes</p>
              <p id="finalMist" class="v">0</p>
              <div class="sub">errors minus allowable errors</div>
            </div>
          </div>

          <div class="divider">
            <div class="history-top">
              <div>
                <div style="color:rgba(255,255,255,.86); font-weight:800; letter-spacing:.15px; font-size:13px;">
                  History (last 20 days)
                </div>
                <div id="historyMini" class="mini" style="margin-top:6px;">No tests saved yet.</div>
              </div>
              <div class="history-actions">
                <button id="btnExport" class="btn" type="button">Export CSV</button>
                <button id="btnClearHistory" class="btn danger" type="button">Clear</button>
              </div>
            </div>

            <div id="spark" class="spark" aria-label="Daily best net speed chart"></div>

            <div class="tablewrap">
              <div class="scroll">
                <table>
                  <thead>
                    <tr>
                      <th>Date</th>
                      <th>Tests</th>
                      <th>Best Net</th>
                      <th>Avg Net</th>
                      <th>Best Acc</th>
                      <th>Avg Acc</th>
                    </tr>
                  </thead>
                  <tbody id="historyTable">
                    <tr><td class="muted" colspan="6">No history yet.</td></tr>
                  </tbody>
                </table>
              </div>
            </div>

            <div style="margin-top:10px; color:var(--muted2); font-size:12.5px; line-height:1.35;">
              Storage is pruned automatically to keep the site fast. Only the last twenty days are kept.
            </div>
          </div>
        </div>
      </section>
    </main>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <div id="modal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="resultTitle">
      <div class="modal-h">
        <h2 id="resultTitle">Test completed</h2>
        <button id="btnClose" class="btn" type="button">Close</button>
      </div>
      <div class="modal-b">
        <div id="resultLines"></div>
        <div class="note">
          Exam net speed formula: total words minus (final mistakes multiplied by ten), then divided by minutes.
          Final mistakes are total errors minus allowable errors (if negative, treated as zero).
        </div>
      </div>
    </div>
  </div>

  <!-- Your existing static word bank -->
  <script src="words.js"></script>

  <script>
    // -------------------------
    // Indraveer Typing Practice
    // -------------------------

    const DURATION_SEC = 10 * 60;

    // Normal English punctuation only (no digits in target generator).
    const PUNCT = [".", ",", ";", ":", "!", "?", "\"", "'", "-", "(", ")"];

    // History storage (small + pruned)
    const STORAGE_KEY = "indraveer_typing_history_v1";
    const KEEP_DAYS = 20;
    const MAX_SESSIONS = 200; // safety cap

    // Word bank from words.js
    const WORDS = (Array.isArray(window.WORDS) && window.WORDS.length >= 1000)
      ? window.WORDS
      : ["the","and","to","of","in","a","is","that","for","it","practice","typing","speed","accuracy","exam","question","answer"];

    const $ = (id) => document.getElementById(id);

    const btnStart = $("btnStart");
    const btnReset = $("btnReset");
    const btnNew = $("btnNew");
    const btnClose = $("btnClose");
    const btnExport = $("btnExport");
    const btnClearHistory = $("btnClearHistory");

    const typebox = $("typebox");
    const targetEl = $("target");
    const progEl = $("prog");
    const timerEl = $("timer");
    const lenInfo = $("lenInfo");
    const toastEl = $("toast");
    const modal = $("modal");
    const resultLines = $("resultLines");
    const statePill = $("statePill");
    const liveWarn = $("liveWarn");

    const grossWpmEl = $("grossWpm");
    const netWpmEl = $("netWpm");
    const accEl = $("acc");
    const errEl = $("err");
    const allowErrEl = $("allowErr");
    const finalMistEl = $("finalMist");

    const historyTable = $("historyTable");
    const historyMini = $("historyMini");
    const spark = $("spark");

    let targetText = "";
    let targetSpans = [];

    let running = false;
    let startPerf = 0;
    let rafId = 0;

    let typed = "";
    let correct = 0;
    let errors = 0;

    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

    function formatTime(sec){
      sec = Math.max(0, Math.ceil(sec));
      const m = Math.floor(sec / 60);
      const s = sec % 60;
      return `${String(m).padStart(2,'0')}:${String(s).padStart(2,'0')}`;
    }

    function showToast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      clearTimeout(showToast._t);
      showToast._t = setTimeout(() => toastEl.classList.remove("show"), 900);
    }

    function randInt(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }

    function buildKeyboard(){
      const chars = [];
      for (let c=65; c<=90; c++) chars.push(String.fromCharCode(c));   // A-Z
      for (let c=97; c<=122; c++) chars.push(String.fromCharCode(c));  // a-z
      chars.push(" ");
      for (const p of PUNCT) chars.push(p);

      const kbd = $("kbd");
      kbd.innerHTML = "";
      for (const ch of chars){
        const d = document.createElement("div");
        d.className = "key";
        d.textContent = ch === " " ? "␠" : ch;
        d.title = ch === " " ? "Space" : ch;
        kbd.appendChild(d);
      }
    }

    function randomWord(){
      return WORDS[randInt(0, WORDS.length - 1)];
    }

    function generateTarget(minChars = 5200){
      // Plain English with punctuation. No digits.
      const parts = [];
      let len = 0;

      while (len < minChars){
        const sentenceLen = randInt(9, 17);
        const words = [];
        for (let i=0;i<sentenceLen;i++) words.push(randomWord());

        // Capitalize first word
        words[0] = words[0][0].toUpperCase() + words[0].slice(1);

        // Mid punctuation
        if (Math.random() < 0.38){
          const k = randInt(2, Math.min(sentenceLen-2, 9));
          const mid = [",",";",":"][randInt(0,2)];
          words[k] = words[k] + mid;
        }

        // Sentence end punctuation
        const r = Math.random();
        const end = r < 0.12 ? "?" : (r < 0.18 ? "!" : ".");
        let sentence = words.join(" ") + end;

        // Sometimes add quotes/parentheses
        if (Math.random() < 0.18) sentence = `"${sentence}"`;
        if (Math.random() < 0.10) sentence = `(${sentence})`;

        parts.push(sentence);

        // Paragraph breaks
        if (Math.random() < 0.12) parts.push("\n\n");
        else parts.push(" ");

        len = parts.join("").length;
      }

      return parts.join("");
    }

    function renderTarget(text){
      targetText = text;
      targetSpans = [];

      const frag = document.createDocumentFragment();
      for (let i=0;i<targetText.length;i++){
        const span = document.createElement("span");
        span.className = "c";
        span.textContent = targetText[i];
        frag.appendChild(span);
        targetSpans.push(span);
      }
      targetEl.innerHTML = "";
      targetEl.appendChild(frag);

      lenInfo.textContent = `Length: ${targetText.length.toLocaleString()} chars`;
      updateCursor(0);
      targetEl.scrollTop = 0;
    }

    // If user reaches end early, append more text (continue till 10 minutes)
    function appendMoreTarget(extraChars = 2200){
      const extra = generateTarget(extraChars);
      const frag = document.createDocumentFragment();
      for (let i=0;i<extra.length;i++){
        const span = document.createElement("span");
        span.className = "c";
        span.textContent = extra[i];
        frag.appendChild(span);
        targetSpans.push(span);
      }
      targetText += extra;
      targetEl.appendChild(frag);
      lenInfo.textContent = `Length: ${targetText.length.toLocaleString()} chars`;
    }

    function updateCursor(pos){
      const old = targetEl.querySelector(".cursor");
      if (old) old.classList.remove("cursor");
      if (pos >= 0 && pos < targetSpans.length) targetSpans[pos].classList.add("cursor");
    }

    function scrollCursorIntoView(pos){
      const span = targetSpans[pos];
      if (!span) return;
      const container = targetEl;
      const top = span.offsetTop;
      const bottom = top + span.offsetHeight;
      const viewTop = container.scrollTop;
      const viewBottom = viewTop + container.clientHeight;

      if (top < viewTop + 18) container.scrollTop = Math.max(0, top - 24);
      else if (bottom > viewBottom - 18) container.scrollTop = bottom - container.clientHeight + 24;
    }

    function setState(label){
      statePill.querySelector("strong").textContent = label;
    }

    function resetStatsUI(){
      grossWpmEl.textContent = "0";
      netWpmEl.textContent = "0";
      accEl.textContent = "100%";
      errEl.textContent = "0";
      allowErrEl.textContent = "0";
      finalMistEl.textContent = "0";
      timerEl.textContent = "10:00";
      progEl.style.width = "0%";
      liveWarn.textContent = "";
    }

    function clearMarking(){
      for (let i=0;i<targetSpans.length;i++){
        targetSpans[i].classList.remove("correct","incorrect");
      }
      updateCursor(0);
      targetEl.scrollTop = 0;
    }

    function forceCaretToEnd(){
      const len = typebox.value.length;
      typebox.selectionStart = typebox.selectionEnd = len;
    }

    function minutesElapsed(nowPerf){
      const elapsedSec = clamp((nowPerf - startPerf) / 1000, 0, DURATION_SEC);
      return Math.max(elapsedSec / 60, 1/60);
    }

    // Screenshot formula
    function computeExamMetrics(minutes){
      const totalChars = typed.length;            // Total Characters: all keystrokes made
      const totalWords = totalChars / 5;          // Total Words: Total Characters / 5
      const allowableErrors = totalWords * 0.05;  // Allowable Errors: 5% of total words
      const totalErrors = errors;                 // Total Errors: count of mistakes
      const finalMistakes = Math.max(0, totalErrors - allowableErrors); // Final mistakes (>= 0)

      // Net Speed (WPM): (Total Words - (Final Mistakes * 10)) / minutes
      const grossWpm = totalWords / minutes;
      const netExamWpm = Math.max(0, (totalWords - (finalMistakes * 10)) / minutes);

      const accuracy = totalChars ? (correct / totalChars) * 100 : 100;

      return { totalChars, totalWords, allowableErrors, totalErrors, finalMistakes, grossWpm, netExamWpm, accuracy };
    }

    function updateLiveStats(nowPerf){
      const mins = minutesElapsed(nowPerf);
      const m = computeExamMetrics(mins);

      grossWpmEl.textContent = Math.floor(m.grossWpm + 1e-9).toString();
      netWpmEl.textContent = Math.floor(m.netExamWpm + 1e-9).toString();
      accEl.textContent = `${m.accuracy.toFixed(2)}%`;
      errEl.textContent = m.totalErrors.toString();
      allowErrEl.textContent = m.allowableErrors.toFixed(2);
      finalMistEl.textContent = m.finalMistakes.toFixed(2);
    }

    function tick(){
      if (!running) return;
      const now = performance.now();
      const elapsed = clamp((now - startPerf) / 1000, 0, DURATION_SEC);
      const left = DURATION_SEC - elapsed;

      timerEl.textContent = formatTime(left);

      // Progress bar as TIME progress (stable even if target becomes infinite)
      const pct = (elapsed / DURATION_SEC) * 100;
      progEl.style.width = `${clamp(pct, 0, 100).toFixed(2)}%`;

      updateLiveStats(now);

      if (left <= 0.0001){
        stopTest();
        return;
      }
      rafId = requestAnimationFrame(tick);
    }

    function startTest(){
      if (running) return;

      // Randomize target every test (your requirement)
      renderTarget(generateTarget());
      clearMarking();

      running = true;
      startPerf = performance.now();
      setState("Running");

      btnStart.disabled = true;
      btnNew.disabled = true;
      btnReset.disabled = false;

      typebox.disabled = false;
      typebox.value = "";
      typed = "";
      correct = 0;
      errors = 0;
      resetStatsUI();

      typebox.focus();
      forceCaretToEnd();

      rafId = requestAnimationFrame(tick);
      showToast("Test started. Backspace/Delete disabled.");
    }

    function stopTest(){
      if (!running) return;

      running = false;
      cancelAnimationFrame(rafId);
      setState("Completed");

      typebox.disabled = true;
      btnStart.disabled = false;
      btnNew.disabled = false;
      btnReset.disabled = false;

      // Final update uses full 10 minutes as per exam test
      const mins = DURATION_SEC / 60;
      const m = computeExamMetrics(mins);

      timerEl.textContent = "00:00";
      openResults(m);

      // Save result day-wise
      saveSession({
        ts: Date.now(),
        grossWpm: Math.floor(m.grossWpm + 1e-9),
        netWpm: Math.floor(m.netExamWpm + 1e-9),
        acc: Number(m.accuracy.toFixed(2)),
        totalChars: m.totalChars,
        totalErrors: m.totalErrors,
        allowableErrors: Number(m.allowableErrors.toFixed(2)),
        finalMistakes: Number(m.finalMistakes.toFixed(2)),
      });

      renderHistory();
    }

    function hardReset(){
      running = false;
      cancelAnimationFrame(rafId);
      setState("Ready");

      typebox.disabled = true;
      typebox.value = "";
      typed = "";
      correct = 0;
      errors = 0;

      resetStatsUI();
      clearMarking();

      btnStart.disabled = false;
      btnNew.disabled = false;
      btnReset.disabled = true;

      showToast("Reset done.");
    }

    function newText(){
      if (running){
        showToast("Finish or reset the test before generating new text.");
        return;
      }
      renderTarget(generateTarget());
      hardReset();
    }

    function openResults(m){
      const lines = [
        ["Total characters", m.totalChars.toLocaleString()],
        ["Total words (characters ÷ five)", m.totalWords.toFixed(2)],
        ["Allowable errors (five percent of total words)", m.allowableErrors.toFixed(2)],
        ["Total errors", m.totalErrors.toLocaleString()],
        ["Final mistakes (errors minus allowable errors)", m.finalMistakes.toFixed(2)],
        ["Gross WPM", Math.floor(m.grossWpm + 1e-9).toString()],
        ["Net speed (exam)", Math.floor(m.netExamWpm + 1e-9).toString()],
        ["Accuracy", `${m.accuracy.toFixed(2)}%`],
      ];

      resultLines.innerHTML = lines.map(([k,v]) =>
        `<div class="resultline"><span>${k}</span><strong>${v}</strong></div>`
      ).join("");

      modal.classList.add("show");
      modal.setAttribute("aria-hidden","false");
    }

    function closeResults(){
      modal.classList.remove("show");
      modal.setAttribute("aria-hidden","true");
    }

    // Strict no-delete + continuous typing
    function onTypeInput(){
      if (!running) return;

      const val = typebox.value;

      // Enforce no deletion (including select-delete)
      if (val.length < typed.length){
        typebox.value = typed;
        forceCaretToEnd();
        liveWarn.textContent = "Deletion is disabled.";
        return;
      }

      forceCaretToEnd();

      const added = val.slice(typed.length);
      if (!added) return;
      liveWarn.textContent = "";

      for (let i=0;i<added.length;i++){
        const ch = added[i];
        const pos = typed.length;

        // If user reached end early, append more target so they can continue
        if (pos >= targetText.length - 1){
          appendMoreTarget(2200);
        }

        const expected = targetText[pos] ?? "";
        const ok = (ch === expected);

        typed += ch;
        if (ok) correct++;
        else errors++;

        if (pos < targetSpans.length){
          targetSpans[pos].classList.add(ok ? "correct" : "incorrect");
        }
        updateCursor(pos + 1);
      }

      scrollCursorIntoView(typed.length);
    }

    function onKeyDown(e){
      if (!running) return;

      // Block Backspace/Delete
      if (e.key === "Backspace" || e.key === "Delete"){
        e.preventDefault();
        showToast("Backspace/Delete is not allowed.");
        return;
      }

      // Block cursor movement keys
      const blocked = ["ArrowLeft","ArrowUp","ArrowRight","ArrowDown","Home","End","PageUp","PageDown"];
      if (blocked.includes(e.key)){
        e.preventDefault();
        showToast("Cursor movement is disabled.");
        forceCaretToEnd();
        return;
      }

      // Block copy/cut/paste/undo/redo/select all
      const ctrl = e.ctrlKey || e.metaKey;
      if (ctrl && ["a","x","v","z","y"].includes(e.key.toLowerCase())){
        e.preventDefault();
        showToast("Copy/Cut/Paste/Undo/Redo is disabled during the test.");
        return;
      }

      // Only allow Enter when the target expects a newline
      if (e.key === "Enter"){
        const pos = typed.length;
        const expected = targetText[pos] ?? "";
        if (expected !== "\n"){
          e.preventDefault();
          showToast("Enter is not expected here.");
        }
      }
    }

    function onPaste(e){
      if (!running) return;
      e.preventDefault();
      showToast("Paste is disabled.");
    }

    function onDrop(e){
      if (!running) return;
      e.preventDefault();
      showToast("Drop is disabled.");
    }

    // -----------------
    // History functions
    // -----------------

    function localDayKey(ts){
      const d = new Date(ts);
      const y = d.getFullYear();
      const m = String(d.getMonth() + 1).padStart(2, "0");
      const da = String(d.getDate()).padStart(2, "0");
      return `${y}-${m}-${da}`;
    }

    function cutoffTimestamp(){
      const now = new Date();
      const startToday = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const cut = new Date(startToday);
      cut.setDate(cut.getDate() - (KEEP_DAYS - 1));
      return cut.getTime();
    }

    function loadHistory(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return [];
        const arr = JSON.parse(raw);
        return Array.isArray(arr) ? arr : [];
      }catch{
        return [];
      }
    }

    function saveHistory(arr){
      try{
        localStorage.setItem(STORAGE_KEY, JSON.stringify(arr));
      }catch{
        // If storage is full or blocked, silently ignore
      }
    }

    function pruneHistory(arr){
      const cut = cutoffTimestamp();
      let out = arr.filter(x => x && typeof x.ts === "number" && x.ts >= cut);

      // keep newest first
      out.sort((a,b) => b.ts - a.ts);

      // cap to MAX_SESSIONS
      if (out.length > MAX_SESSIONS) out = out.slice(0, MAX_SESSIONS);

      return out;
    }

    function saveSession(session){
      const hist = pruneHistory(loadHistory());
      hist.unshift(session);
      saveHistory(pruneHistory(hist));
    }

    function groupByDay(hist){
      const map = new Map();
      for (const s of hist){
        const key = localDayKey(s.ts);
        if (!map.has(key)) map.set(key, []);
        map.get(key).push(s);
      }
      return map;
    }

    function avg(nums){
      if (!nums.length) return 0;
      return nums.reduce((a,b)=>a+b,0) / nums.length;
    }

    function renderHistory(){
      const hist = pruneHistory(loadHistory());
      if (!hist.length){
        historyMini.textContent = "No tests saved yet.";
        historyTable.innerHTML = `<tr><td class="muted" colspan="6">No history yet.</td></tr>`;
        spark.innerHTML = "";
        return;
      }

      const byDay = groupByDay(hist);

      // Build daily summaries (descending by day)
      const days = Array.from(byDay.keys()).sort((a,b) => (a < b ? 1 : -1));
      const rows = [];

      const daily = days.map(day => {
        const sessions = byDay.get(day);
        const nets = sessions.map(s => Number(s.netWpm || 0));
        const accs = sessions.map(s => Number(s.acc || 0));
        return {
          day,
          count: sessions.length,
          bestNet: Math.max(...nets),
          avgNet: avg(nets),
          bestAcc: Math.max(...accs),
          avgAcc: avg(accs),
        };
      });

      for (const d of daily){
        rows.push(`
          <tr>
            <td>${d.day}</td>
            <td class="muted">${d.count}</td>
            <td><strong>${Math.round(d.bestNet)}</strong></td>
            <td class="muted">${d.avgNet.toFixed(1)}</td>
            <td><strong>${d.bestAcc.toFixed(2)}%</strong></td>
            <td class="muted">${d.avgAcc.toFixed(2)}%</td>
          </tr>
        `);
      }
      historyTable.innerHTML = rows.join("");

      // Mini summary (today + last 7 days)
      const todayKey = localDayKey(Date.now());
      const todaySessions = byDay.get(todayKey) || [];
      const todayBest = todaySessions.length ? Math.max(...todaySessions.map(s => Number(s.netWpm||0))) : 0;

      const last7 = daily.slice(0, 7);
      const last7Avg = last7.length ? avg(last7.map(d => d.avgNet)) : 0;

      const totalTests = hist.length;
      const bestNetOverall = Math.max(...hist.map(s => Number(s.netWpm || 0)));

      historyMini.innerHTML =
        `Today best net: <strong>${Math.round(todayBest)}</strong> • ` +
        `7-day avg net: <strong>${last7Avg.toFixed(1)}</strong> • ` +
        `Best net (all saved): <strong>${Math.round(bestNetOverall)}</strong> • ` +
        `Tests saved: <strong>${totalTests}</strong>`;

      // Spark bars (best net per day)
      const maxNet = Math.max(...daily.map(d => d.bestNet), 1);
      spark.innerHTML = "";
      // show up to 20 bars (already max 20 days)
      daily.slice().reverse().forEach((d) => {
        const h = Math.max(6, Math.round((d.bestNet / maxNet) * 56));
        const div = document.createElement("div");
        div.className = "bar" + (d.day === todayKey ? " best" : "");
        div.style.height = `${h}px`;
        div.title = `${d.day} • best net ${Math.round(d.bestNet)} • tests ${d.count}`;
        spark.appendChild(div);
      });
    }

    function exportCSV(){
      const hist = pruneHistory(loadHistory());
      if (!hist.length){
        showToast("No history to export.");
        return;
      }
      const header = [
        "timestamp",
        "date",
        "grossWpm",
        "netWpm",
        "accuracy",
        "totalChars",
        "totalErrors",
        "allowableErrors",
        "finalMistakes"
      ];
      const lines = [header.join(",")];

      for (const s of hist.slice().reverse()){
        const ts = s.ts;
        const date = localDayKey(ts);
        const row = [
          new Date(ts).toISOString(),
          date,
          s.grossWpm ?? "",
          s.netWpm ?? "",
          s.acc ?? "",
          s.totalChars ?? "",
          s.totalErrors ?? "",
          s.allowableErrors ?? "",
          s.finalMistakes ?? ""
        ];
        lines.push(row.join(","));
      }

      const blob = new Blob([lines.join("\n")], { type: "text/csv;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `indraveer-typing-history-${localDayKey(Date.now())}.csv`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function clearHistory(){
      try{
        localStorage.removeItem(STORAGE_KEY);
      }catch{}
      renderHistory();
      showToast("History cleared.");
    }

    // Buttons
    btnStart.addEventListener("click", startTest);
    btnReset.addEventListener("click", hardReset);
    btnNew.addEventListener("click", newText);
    btnClose.addEventListener("click", closeResults);
    btnExport.addEventListener("click", exportCSV);
    btnClearHistory.addEventListener("click", clearHistory);

    // Modal close by clicking outside
    modal.addEventListener("click", (e) => { if (e.target === modal) closeResults(); });

    // Input listeners
    typebox.addEventListener("input", onTypeInput);
    typebox.addEventListener("keydown", onKeyDown);
    typebox.addEventListener("paste", onPaste);
    typebox.addEventListener("drop", onDrop);
    typebox.addEventListener("contextmenu", (e) => { if (running) e.preventDefault(); });
    typebox.addEventListener("mouseup", () => { if (running) forceCaretToEnd(); });
    typebox.addEventListener("keyup", () => { if (running) forceCaretToEnd(); });
    typebox.addEventListener("focus", () => { if (running) forceCaretToEnd(); });

    // Init
    buildKeyboard();
    renderTarget(generateTarget());
    hardReset();
    renderHistory();
  </script>
</body>
</html>
