<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Indraveer Typing Practice — Railway / SSC Style</title>
  <style>
    :root{
      --bg1:#0b1020;
      --bg2:#101a3a;
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.70);
      --muted2:rgba(255,255,255,.55);
      --good:#3ddc97;
      --bad:#ff5a7a;
      --warn:#ffd166;
      --stroke:rgba(255,255,255,.12);
      --stroke2:rgba(255,255,255,.18);
      --shadow: 0 18px 60px rgba(0,0,0,.40);
      --radius: 20px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 600px at 15% 10%, rgba(124, 92, 255, .30), transparent 60%),
        radial-gradient(900px 500px at 85% 20%, rgba(0, 212, 255, .20), transparent 55%),
        radial-gradient(800px 500px at 50% 90%, rgba(61, 220, 151, .16), transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      overflow-x:hidden;
    }

    .app{ max-width: 1220px; margin: 0 auto; padding: 26px 16px 44px; }
    header{ display:flex; align-items:center; justify-content:space-between; gap: 14px; margin-bottom: 14px; flex-wrap:wrap; }

    .brand{ display:flex; align-items:center; gap: 12px; user-select:none; }
    .logo{
      width: 42px; height: 42px; border-radius: 14px;
      background: linear-gradient(135deg, rgba(124, 92, 255, .9), rgba(0, 212, 255, .6));
      box-shadow: 0 10px 30px rgba(124,92,255,.18);
      position: relative; overflow:hidden;
    }
    .logo:before{
      content:""; position:absolute; inset:-30%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.55), transparent 55%);
      transform: rotate(18deg);
    }

    h1{ font-size: 18px; line-height: 1.2; margin: 0; letter-spacing:.2px; }
    .subtitle{ margin: 3px 0 0; font-size: 12.5px; color: var(--muted); }

    .header-actions{ display:flex; align-items:center; gap: 10px; flex-wrap:wrap; justify-content:flex-end; }

    .btn{
      appearance:none;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.05);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      cursor:pointer;
      font-weight: 700;
      font-size: 13px;
      letter-spacing:.15px;
      box-shadow: 0 10px 26px rgba(0,0,0,.18);
      transition: transform .12s ease, border-color .12s ease, background .12s ease;
      white-space:nowrap;
    }
    .btn:hover{ transform: translateY(-1px); border-color: var(--stroke2); background: rgba(255,255,255,.07); }
    .btn:active{ transform: translateY(0px); }
    .btn.primary{ border-color: rgba(61,220,151,.35); background: rgba(61,220,151,.12); }
    .btn.warn{ border-color: rgba(255,209,102,.35); background: rgba(255,209,102,.10); }
    .btn.danger{ border-color: rgba(255,90,122,.38); background: rgba(255,90,122,.10); }
    .btn:disabled{ cursor:not-allowed; opacity:.55; transform:none; }

    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding: 8px 10px; border-radius: 999px;
      background: rgba(255,255,255,.05);
      border: 1px solid var(--stroke);
      color: var(--muted);
      font-size: 12.5px;
      user-select:none;
    }

    main{ display:grid; grid-template-columns: 320px 1fr 360px; gap: 14px; }
    @media (max-width: 1100px){ main{ grid-template-columns: 1fr; } }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.04));
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .card .card-h{
      display:flex; align-items:center; justify-content:space-between; gap: 10px;
      padding: 14px 16px;
      border-bottom: 1px solid var(--stroke);
      background: rgba(0,0,0,.12);
    }
    .card .card-h .title{
      margin:0; font-size: 13px; letter-spacing:.25px;
      color: rgba(255,255,255,.86);
      font-weight: 850; text-transform: uppercase;
    }
    .card .card-b{ padding: 14px 16px 16px; }

    .rule{ display:flex; gap: 10px; margin: 10px 0; color: var(--muted); font-size: 13px; line-height: 1.35; }
    .dot{ flex: 0 0 auto; width: 10px; height: 10px; border-radius: 50%; margin-top: 4px; background: rgba(255,255,255,.18); border: 1px solid rgba(255,255,255,.22); }
    .dot.good{ background: rgba(61,220,151,.22); border-color: rgba(61,220,151,.35); }
    .dot.bad{ background: rgba(255,90,122,.18); border-color: rgba(255,90,122,.35); }
    .dot.warn{ background: rgba(255,209,102,.18); border-color: rgba(255,209,102,.35); }

    .kbdgrid{ display:grid; grid-template-columns: repeat(10, minmax(0, 1fr)); gap: 6px; margin-top: 10px; }
    .key{
      font-family: var(--mono);
      font-size: 12.5px;
      padding: 7px 0;
      border-radius: 12px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.10);
      text-align:center;
      color: rgba(255,255,255,.82);
      user-select:none;
    }

    .progress{
      height: 10px; border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      overflow:hidden;
    }
    .progress > div{
      height:100%; width:0%;
      background: linear-gradient(90deg, rgba(124,92,255,.75), rgba(0,212,255,.65), rgba(61,220,151,.65));
      border-radius:999px;
      transition: width .18s ease;
    }

    .target{
      height: 260px;
      padding: 14px 16px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      overflow:auto;
      font-family: var(--mono);
      line-height: 1.65;
      font-size: 14px;
      letter-spacing: .15px;
      scroll-behavior:smooth;
    }

    .target .c{ white-space: pre-wrap; }
    .target .c.correct{ color: rgba(61,220,151,.92); }
    .target .c.incorrect{
      color: rgba(255,90,122,.95);
      text-decoration: underline;
      text-decoration-thickness: 2px;
      text-underline-offset: 3px;
    }
    .target .c.cursor{
      background: rgba(255,255,255,.16);
      border-radius: 3px;
      outline: 1px solid rgba(255,255,255,.18);
    }

    .typebox{
      width:100%;
      min-height: 170px;
      padding: 14px 16px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      color: var(--text);
      font-family: var(--mono);
      font-size: 15px;
      line-height: 1.55;
      resize: vertical;
      outline: none;
      box-shadow: 0 14px 40px rgba(0,0,0,.25);
    }
    .typebox:focus{ border-color: rgba(0,212,255,.35); }

    .hint{
      margin-top: 10px;
      display:flex; flex-wrap:wrap; gap: 8px;
      align-items:center; justify-content:space-between;
      color: var(--muted2);
      font-size: 12.5px;
      line-height: 1.25;
    }

    .toast{
      position: fixed; left: 50%; bottom: 16px;
      transform: translateX(-50%);
      background: rgba(0,0,0,.65);
      border: 1px solid rgba(255,255,255,.16);
      color: rgba(255,255,255,.92);
      padding: 10px 12px;
      border-radius: 999px;
      font-size: 13px;
      box-shadow: 0 14px 50px rgba(0,0,0,.45);
      opacity: 0; pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
      z-index: 999;
      max-width: min(92vw, 860px);
      text-align:center;
    }
    .toast.show{ opacity: 1; transform: translateX(-50%) translateY(-2px); }

    .statgrid{ display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .stat{
      padding: 12px 12px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.14);
    }
    .stat .k{ font-size: 12px; color: var(--muted); letter-spacing:.2px; margin:0 0 6px; }
    .stat .v{ margin:0; font-size: 20px; font-weight: 900; letter-spacing:.2px; }
    .stat .sub{ margin-top: 6px; font-size: 12.2px; color: var(--muted2); line-height:1.25; }

    .big{ grid-column: 1 / -1; display:flex; align-items:flex-end; justify-content:space-between; gap: 10px; }
    .timer{ font-family: var(--mono); font-size: 28px; font-weight: 950; letter-spacing: .8px; margin:0; }
    .status{ display:flex; flex-wrap:wrap; gap: 8px; justify-content:flex-end; }

    .divider{ margin: 14px 0 0; padding-top: 14px; border-top: 1px solid rgba(255,255,255,.10); }

    .tablewrap{
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      background: rgba(0,0,0,.12);
      overflow:hidden;
    }
    table{ width:100%; border-collapse: collapse; font-size: 12.5px; }
    thead th{
      text-align:left; padding: 10px 10px;
      background: rgba(255,255,255,.04);
      border-bottom: 1px solid rgba(255,255,255,.10);
      color: rgba(255,255,255,.80);
      font-weight: 850;
      letter-spacing:.15px;
      white-space:nowrap;
    }
    tbody td{
      padding: 9px 10px;
      border-bottom: 1px solid rgba(255,255,255,.07);
      color: rgba(255,255,255,.86);
      white-space:nowrap;
    }
    tbody tr:last-child td{ border-bottom:none; }
    tbody td.muted{ color: var(--muted2); }
    .scroll{ max-height: 240px; overflow:auto; }

    .modal{ position: fixed; inset: 0; display:none; place-items:center; background: rgba(0,0,0,.55); z-index: 1000; padding: 18px; }
    .modal.show{ display:grid; }
    .modal-card{
      width: min(860px, 100%);
      border-radius: 24px;
      border: 1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      box-shadow: 0 30px 90px rgba(0,0,0,.55);
      overflow:hidden;
    }
    .modal-h{
      padding: 16px 18px;
      border-bottom: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.16);
      display:flex; align-items:center; justify-content:space-between; gap: 10px;
    }
    .modal-h h2{ margin:0; font-size: 16px; letter-spacing:.2px; }
    .modal-b{ padding: 16px 18px 18px; }
    .resultgrid{ display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .resultline{
      display:flex; justify-content:space-between; gap: 14px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.12);
      border-radius: 14px;
      color: var(--muted);
      font-size: 13.5px;
    }
    .resultline strong{ color: rgba(255,255,255,.92); }
    .note{ margin-top: 12px; color: var(--muted2); font-size: 12.5px; line-height: 1.35; }

    .sr-only{ position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }
    code.k{ font-family: var(--mono); font-size: 12.5px; color: rgba(255,255,255,.84); }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1>Indraveer Typing Practice</h1>
          <p class="subtitle">Railway / SSC-style CBTST simulation • 1 min warm-up + 30 sec break + 10 min test • no backspace • retype passage</p>
        </div>
      </div>
      <div class="header-actions">
        <span class="pill" title="Backspace and Delete are disabled in warmup and test.">⌫ Backspace: <strong style="color:rgba(255,255,255,.92)">Not allowed</strong></span>
        <button id="btnNew" class="btn" type="button">New passage</button>
        <button id="btnCBTST" class="btn primary" type="button">Start CBTST</button>
        <button id="btnTestOnly" class="btn warn" type="button">Start 10-min only</button>
        <button id="btnReset" class="btn danger" type="button" disabled>Reset</button>
      </div>
    </header>

    <main>
      <section class="card">
        <div class="card-h"><p class="title">Railway / SSC rules & scoring</p></div>
        <div class="card-b">
          <div class="rule"><span class="dot good"></span><span><strong>Stages:</strong> warm-up 1 minute, break 30 seconds, typing test 10 minutes.</span></div>
          <div class="rule"><span class="dot good"></span><span><strong>Retype:</strong> after finishing the passage, type it again from the beginning (app loops automatically).</span></div>
          <div class="rule"><span class="dot warn"></span><span><strong>Minimum words:</strong> if total words typed is <strong>&lt; 300</strong>, result is “not evaluated”.</span></div>
          <div class="rule"><span class="dot bad"></span><span><strong>Disqualify:</strong> if you do not complete the passage at least once, result is “disqualified”.</span></div>

          <div style="margin-top:12px; color:rgba(255,255,255,.86); font-weight:850; letter-spacing:.2px;">Mistake calculation</div>
          <div class="rule"><span class="dot"></span><span><strong>Total mistakes</strong> = Full + (Half ÷ 2)</span></div>
          <div class="rule"><span class="dot"></span><span><strong>Allowable errors</strong> = 5% of total words typed</span></div>
          <div class="rule"><span class="dot"></span><span><strong>Final mistakes</strong> = max(0, Total − Allowable)</span></div>
          <div class="rule"><span class="dot"></span><span><strong>Net WPM</strong> = (TotalWords − (FinalMistakes × 10)) ÷ 10</span></div>

          <div style="margin-top:10px; color:var(--muted2); font-size:12.5px; line-height:1.35;">
            <strong>Exam word standard:</strong> This app uses <strong>totalCharacters ÷ 5</strong> as “Total Words typed” (same style as many typing platforms).
            It also shows a “raw word count” just for reference.
          </div>

          <div style="margin-top:14px; color:var(--muted); font-size:13px;">Characters used in the passage:</div>
          <div id="kbd" class="kbdgrid" aria-label="Character set"></div>
        </div>
      </section>

      <section class="card">
        <div class="card-h">
          <p class="title">Passage</p>
          <div style="display:flex; gap:10px; align-items:center; color:var(--muted); font-size:12.5px;">
            <span id="lenInfo">Length: —</span>
          </div>
        </div>
        <div class="card-b" style="display:flex; flex-direction:column; gap:12px;">
          <div class="progress" aria-label="time progress"><div id="prog"></div></div>
          <div id="target" class="target" aria-label="Target passage"></div>
          <div>
            <label class="sr-only" for="typebox">Typing input</label>
            <textarea id="typebox" class="typebox" placeholder="Press Start, then type here…" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off" disabled></textarea>
            <div class="hint">
              <span id="stageHint">Ready.</span>
              <span id="liveWarn" aria-live="polite"></span>
            </div>
          </div>
        </div>
      </section>

      <section class="card">
        <div class="card-h"><p class="title">Stats & history</p></div>
        <div class="card-b">
          <div class="statgrid">
            <div class="stat big">
              <div>
                <p class="k">Timer</p>
                <p id="timer" class="timer">00:00</p>
              </div>
              <div class="status">
                <span id="statePill" class="pill">Status: <strong style="color:rgba(255,255,255,.92)">Ready</strong></span>
              </div>
            </div>

            <div class="stat">
              <p class="k">Exam words typed</p>
              <p id="wordsTyped" class="v">0</p>
              <div class="sub">= characters ÷ 5</div>
            </div>

            <div class="stat">
              <p class="k">Raw words (reference)</p>
              <p id="rawWords" class="v">0</p>
              <div class="sub">split by spaces</div>
            </div>

            <div class="stat">
              <p class="k">Passage completed</p>
              <p id="passageDone" class="v">0</p>
              <div class="sub">times completed in test</div>
            </div>

            <div class="stat">
              <p class="k">Live WPM</p>
              <p id="liveWpm" class="v">0</p>
              <div class="sub">based on elapsed time</div>
            </div>

            <div class="stat">
              <p class="k">Full mistakes</p>
              <p id="fullMist" class="v">0</p>
              <div class="sub">wrong/missing/extra word</div>
            </div>

            <div class="stat">
              <p class="k">Half mistakes</p>
              <p id="halfMist" class="v">0</p>
              <div class="sub">one character difference</div>
            </div>

            <div class="stat">
              <p class="k">Allowable errors</p>
              <p id="allowErr" class="v">0</p>
              <div class="sub">5% of total words</div>
            </div>

            <div class="stat">
              <p class="k">Final mistakes</p>
              <p id="finalMist" class="v">0</p>
              <div class="sub">after 5% ignored</div>
            </div>

            <div class="stat">
              <p class="k">Exam gross (10 min)</p>
              <p id="grossWpm" class="v">0</p>
              <div class="sub">totalWords ÷ 10</div>
            </div>

            <div class="stat">
              <p class="k">Net speed (WPM)</p>
              <p id="netWpm" class="v">0</p>
              <div class="sub">(words − final×10) ÷ 10</div>
            </div>

            <div class="stat">
              <p class="k">Character accuracy</p>
              <p id="acc" class="v">100%</p>
              <div class="sub">practice feedback</div>
            </div>

            <div class="stat">
              <p class="k">Word bank loaded</p>
              <p id="bankInfo" class="v">—</p>
              <div class="sub">from words.js</div>
            </div>
          </div>

          <div class="divider">
            <div style="display:flex; align-items:flex-start; justify-content:space-between; gap: 10px; flex-wrap:wrap;">
              <div>
                <div style="color:rgba(255,255,255,.86); font-weight:900; letter-spacing:.15px; font-size:13px;">
                  Results history (last 20 days)
                </div>
                <div id="historyMini" style="margin-top:6px; color:var(--muted2); font-size:12.5px;">No tests saved yet.</div>
              </div>
              <div style="display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;">
                <button id="btnExport" class="btn" type="button">Export CSV</button>
                <button id="btnClearHistory" class="btn danger" type="button">Clear</button>
              </div>
            </div>

            <div class="tablewrap" style="margin-top:10px;">
              <div class="scroll">
                <table>
                  <thead>
                    <tr>
                      <th>Date</th>
                      <th>Tests</th>
                      <th>Best Net</th>
                      <th>Avg Net</th>
                      <th>Best Status</th>
                    </tr>
                  </thead>
                  <tbody id="historyTable">
                    <tr><td class="muted" colspan="5">No history yet.</td></tr>
                  </tbody>
                </table>
              </div>
            </div>

            <div style="margin-top:10px; color:var(--muted2); font-size:12.5px; line-height:1.35;">
              Stored locally in your browser (localStorage). Auto-pruned to stay fast.
            </div>
          </div>
        </div>
      </section>
    </main>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <div id="modal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="resultTitle">
      <div class="modal-h">
        <h2 id="resultTitle">Test result (10 minutes)</h2>
        <button id="btnClose" class="btn" type="button">Close</button>
      </div>
      <div class="modal-b">
        <div id="resultGrid" class="resultgrid"></div>
        <div class="note">
          Net WPM formula:
          <code class="k">(TotalWords − (FinalMistakes × 10)) ÷ 10</code>.
          Final mistakes are
          <code class="k">max(0, TotalMistakes − 0.05×TotalWords)</code>.
          Here TotalWords = <code class="k">totalCharacters ÷ 5</code>.
        </div>
      </div>
    </div>
  </div>

  <!-- ONLY words.js -->
  <script src="words.js"></script>

  <script>
    // -------------------------
    // Indraveer Typing Practice
    // Railway / SSC CBTST style
    // -------------------------

    // Stages
    const STAGE_IDLE   = "idle";
    const STAGE_WARMUP = "warmup";
    const STAGE_BREAK  = "break";
    const STAGE_TEST   = "test";
    const STAGE_DONE   = "done";

    const WARMUP_SEC = 60;
    const BREAK_SEC  = 30;
    const TEST_SEC   = 10 * 60;

    const MIN_WORDS_EN = 300;
    const KEEP_DAYS = 20;
    const MAX_SESSIONS = 200;
    const STORAGE_KEY = "indraveer_cbtst_history_v3";

    // Exam standard: 1 word = 5 characters
    const WORD_UNIT = 5;

    // Typical English punctuation set (no digits)
    const PUNCT = [".", ",", ";", ":", "!", "?", "\"", "'", "-", "(", ")"];

    // Word bank
    const WORD_BANK = (Array.isArray(window.WORDS) && window.WORDS.length >= 1000)
      ? window.WORDS
      : ["the","and","to","of","in","a","is","that","for","it","practice","typing","speed","accuracy","exam","railway","candidate","result","mistake","final"];

    const $ = (id) => document.getElementById(id);

    // Buttons
    const btnNew = $("btnNew");
    const btnCBTST = $("btnCBTST");
    const btnTestOnly = $("btnTestOnly");
    const btnReset = $("btnReset");
    const btnClose = $("btnClose");
    const btnExport = $("btnExport");
    const btnClearHistory = $("btnClearHistory");

    // UI elements
    const targetEl = $("target");
    const typebox = $("typebox");
    const lenInfo = $("lenInfo");
    const stageHint = $("stageHint");
    const liveWarn = $("liveWarn");
    const progEl = $("prog");
    const timerEl = $("timer");
    const toastEl = $("toast");
    const modal = $("modal");
    const resultGrid = $("resultGrid");

    const statePill = $("statePill");
    const wordsTypedEl = $("wordsTyped");
    const rawWordsEl = $("rawWords");
    const passageDoneEl = $("passageDone");
    const liveWpmEl = $("liveWpm");
    const fullMistEl = $("fullMist");
    const halfMistEl = $("halfMist");
    const allowErrEl = $("allowErr");
    const finalMistEl = $("finalMist");
    const grossWpmEl = $("grossWpm");
    const netWpmEl = $("netWpm");
    const accEl = $("acc");
    const bankInfoEl = $("bankInfo");

    const historyMini = $("historyMini");
    const historyTable = $("historyTable");

    // Passage render
    let basePassageText = "";
    let basePassageChars = 0;
    let basePassageWords = [];

    let targetSpans = [];

    // Typing state
    let stage = STAGE_IDLE;
    let stageStartPerf = 0;
    let stageDurationSec = 0;
    let rafId = 0;

    let typed = "";
    let correctChars = 0;
    let wrongChars = 0;

    // passage completion count (precise by character wrap)
    let passageCompleted = 0;

    function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }
    function randInt(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }

    function showToast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      clearTimeout(showToast._t);
      showToast._t = setTimeout(() => toastEl.classList.remove("show"), 1000);
    }

    function setState(label){
      statePill.querySelector("strong").textContent = label;
    }

    function formatTime(sec){
      sec = Math.max(0, Math.ceil(sec));
      const m = Math.floor(sec/60);
      const s = sec % 60;
      return `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
    }

    function forceCaretToEnd(){
      const len = typebox.value.length;
      typebox.selectionStart = typebox.selectionEnd = len;
    }

    function buildKeyboard(){
      const chars = [];
      for (let c=65;c<=90;c++) chars.push(String.fromCharCode(c));
      for (let c=97;c<=122;c++) chars.push(String.fromCharCode(c));
      chars.push(" ");
      for (const p of PUNCT) chars.push(p);

      const kbd = $("kbd");
      kbd.innerHTML = "";
      for (const ch of chars){
        const d = document.createElement("div");
        d.className = "key";
        d.textContent = ch === " " ? "␠" : ch;
        d.title = ch === " " ? "Space" : ch;
        kbd.appendChild(d);
      }
    }

    function tokenizeWords(text){
      const m = text.match(/\S+/g);
      return m ? m : [];
    }

    function randomWord(){
      return WORD_BANK[randInt(0, WORD_BANK.length-1)];
    }

    function generateMeaningfulPassage(targetWords = 350){
      const connectors = ["however","therefore","because","although","while","when","where","unless","since","after","before"];
      const starters = ["Candidates","The system","This passage","A student","A worker","The committee","The officer","The report","A decision","The process"];

      const parts = [];
      let madeWords = 0;

      while (madeWords < targetWords){
        const sentenceLen = randInt(14, 22);
        const first = starters[randInt(0, starters.length-1)];
        const sentence = [first];

        for (let i=1;i<sentenceLen && madeWords < targetWords;i++){
          let w = randomWord();
          if (Math.random() < 0.10) w = connectors[randInt(0, connectors.length-1)];
          sentence.push(w);
          madeWords++;
        }

        sentence[0] = sentence[0][0].toUpperCase() + sentence[0].slice(1);

        if (Math.random() < 0.65 && sentence.length >= 8){
          const k = randInt(3, sentence.length-4);
          const mid = [",",";",":"][randInt(0,2)];
          sentence[k] = sentence[k] + mid;
        }

        const r = Math.random();
        const end = r < 0.12 ? "?" : (r < 0.18 ? "!" : ".");
        let line = sentence.join(" ") + end;

        if (Math.random() < 0.10) line = `"${line}"`;
        if (Math.random() < 0.08) line = `(${line})`;

        parts.push(line);
        parts.push(Math.random() < 0.18 ? "\n\n" : " ");
      }

      return parts.join("").replace(/\s+\n/g, "\n").replace(/\n\s+/g, "\n").trim();
    }

    function renderPassage(text){
      basePassageText = text;
      basePassageChars = basePassageText.length;
      basePassageWords = tokenizeWords(basePassageText);

      // render once only (looping is done via modulo)
      targetEl.innerHTML = "";
      targetSpans = [];

      const frag = document.createDocumentFragment();
      for (let i=0;i<basePassageText.length;i++){
        const s = document.createElement("span");
        s.className = "c";
        s.textContent = basePassageText[i];
        frag.appendChild(s);
        targetSpans.push(s);
      }
      targetEl.appendChild(frag);

      lenInfo.textContent = `Length: ${basePassageChars.toLocaleString()} chars • (~${(basePassageChars/WORD_UNIT).toFixed(0)} exam-words)`;
      setCursor(0);
      targetEl.scrollTop = 0;
    }

    function clearMarking(){
      for (const s of targetSpans) s.classList.remove("correct","incorrect","cursor");
      setCursor(0);
      targetEl.scrollTop = 0;
    }

    function setCursor(loopPos){
      for (const s of targetSpans) s.classList.remove("cursor");
      if (loopPos >= 0 && loopPos < targetSpans.length) targetSpans[loopPos].classList.add("cursor");
    }

    function scrollCursorIntoView(loopPos){
      const span = targetSpans[loopPos];
      if (!span) return;
      const top = span.offsetTop;
      const bottom = top + span.offsetHeight;
      const viewTop = targetEl.scrollTop;
      const viewBottom = viewTop + targetEl.clientHeight;

      if (top < viewTop + 18) targetEl.scrollTop = Math.max(0, top - 24);
      else if (bottom > viewBottom - 18) targetEl.scrollTop = bottom - targetEl.clientHeight + 24;
    }

    function resetCounters(){
      typed = "";
      correctChars = 0;
      wrongChars = 0;
      passageCompleted = 0;

      typebox.value = "";
      liveWarn.textContent = "";

      wordsTypedEl.textContent = "0";
      rawWordsEl.textContent = "0";
      passageDoneEl.textContent = "0";
      liveWpmEl.textContent = "0";
      fullMistEl.textContent = "0";
      halfMistEl.textContent = "0";
      allowErrEl.textContent = "0";
      finalMistEl.textContent = "0";
      grossWpmEl.textContent = "0";
      netWpmEl.textContent = "0";
      accEl.textContent = "100%";

      clearMarking();
      forceCaretToEnd();
    }

    // --- Half-mistake check (one edit away) ---
    function isHalfMistakeWord(a, b){
      if (a === b) return false;
      if (!a || !b) return false;
      if (a.toLowerCase() === b.toLowerCase()) return true;

      const la = a.length, lb = b.length;
      if (Math.abs(la - lb) > 1) return false;

      if (la === lb){
        let diff = 0;
        for (let i=0;i<la;i++){
          if (a[i] !== b[i]) { diff++; if (diff > 1) return false; }
        }
        return diff === 1;
      }

      const shorter = la < lb ? a : b;
      const longer  = la < lb ? b : a;
      let i = 0, j = 0, edits = 0;
      while (i < shorter.length && j < longer.length){
        if (shorter[i] === longer[j]) { i++; j++; }
        else { edits++; if (edits > 1) return false; j++; }
      }
      return true;
    }

    // --- DP alignment to compute full/half mistakes ---
    function computeMistakesWordAlignment(typedWords, expectedWords){
      const n = typedWords.length;
      const m = expectedWords.length;

      const dir = new Uint8Array((n+1)*(m+1));
      const prev = new Float32Array(m+1);
      const curr = new Float32Array(m+1);

      prev[0] = 0;
      for (let j=1;j<=m;j++){ prev[j] = prev[j-1] + 1; dir[0*(m+1)+j] = 2; }

      for (let i=1;i<=n;i++){
        curr[0] = prev[0] + 1;
        dir[i*(m+1)+0] = 1;

        const tw = typedWords[i-1];
        for (let j=1;j<=m;j++){
          const ew = expectedWords[j-1];

          let subCost = 0;
          let subDir = 3; // match
          if (tw === ew){ subCost = 0; subDir = 3; }
          else if (isHalfMistakeWord(tw, ew)){ subCost = 0.5; subDir = 4; }
          else { subCost = 1; subDir = 5; }

          const costIns = prev[j] + 1;
          const costDel = curr[j-1] + 1;
          const costSub = prev[j-1] + subCost;

          let best = costSub;
          let bestDir = subDir;

          if (costDel < best - 1e-6){ best = costDel; bestDir = 2; }
          if (costIns < best - 1e-6){ best = costIns; bestDir = 1; }

          curr[j] = best;
          dir[i*(m+1)+j] = bestDir;
        }
        prev.set(curr);
      }

      // Best end j (no penalty for leaving expected remainder)
      let bestJ = 0, bestCost = prev[0];
      for (let j=1;j<=m;j++){ if (prev[j] < bestCost){ bestCost = prev[j]; bestJ = j; } }

      let i = n, j = bestJ;
      let full = 0, half = 0;
      while (i > 0 || j > 0){
        if (i === 0){ full += j; break; }
        if (j === 0){ full += i; break; }

        const code = dir[i*(m+1)+j];
        if (code === 1){ full++; i--; }
        else if (code === 2){ full++; j--; }
        else if (code === 3){ i--; j--; }
        else if (code === 4){ half++; i--; j--; }
        else if (code === 5){ full++; i--; j--; }
        else { i--; j--; }
      }
      return { fullMistakes: full, halfMistakes: half };
    }

    function computeFinalTestMetrics(){
      // exam words = characters/5
      const totalChars = typed.length;
      const totalWords = totalChars / WORD_UNIT;

      // expected repeated words for alignment (for mistakes)
      const typedWords = tokenizeWords(typed);
      const baseLen = basePassageWords.length || 1;
      const needRepeats = Math.max(1, Math.ceil((typedWords.length + baseLen) / baseLen));
      const expectedWords = [];
      for (let r=0;r<needRepeats;r++) expectedWords.push(...basePassageWords);

      const align = computeMistakesWordAlignment(typedWords, expectedWords);
      const totalMistakes = align.fullMistakes + (align.halfMistakes / 2);
      const allowable = totalWords * 0.05;
      const finalMist = Math.max(0, totalMistakes - allowable);

      const grossWpmExam = totalWords / 10;
      const netWpm = Math.max(0, (totalWords - (finalMist * 10)) / 10);

      const charAcc = totalChars ? (correctChars / totalChars) * 100 : 100;

      let status = "Evaluated";
      if (totalWords < MIN_WORDS_EN) status = "Not evaluated (<300 words)";
      if (passageCompleted < 1) status = "Disqualified (passage not completed)";

      return {
        status,
        totalChars,
        totalWords,
        rawWords: tokenizeWords(typed).length,
        passagesCompleted: passageCompleted,
        fullMistakes: align.fullMistakes,
        halfMistakes: align.halfMistakes,
        totalMistakes,
        allowable,
        finalMist,
        grossWpmExam,
        netWpm,
        charAcc
      };
    }

    function setTimerUI(secLeft){ timerEl.textContent = formatTime(secLeft); }
    function setProgressUI(left){
      const total = stage === STAGE_WARMUP ? WARMUP_SEC : stage === STAGE_BREAK ? BREAK_SEC : stage === STAGE_TEST ? TEST_SEC : 1;
      const elapsed = Math.max(0, stageDurationSec - left);
      progEl.style.width = `${clamp((elapsed/total)*100, 0, 100)}%`;
    }

    function startStageWarmup(){
      stopTicker();
      stage = STAGE_WARMUP;
      stageDurationSec = WARMUP_SEC;
      stageStartPerf = performance.now();

      renderPassage(generateMeaningfulPassage(180));
      resetCounters();

      typebox.disabled = false;
      btnReset.disabled = false;
      btnCBTST.disabled = true;
      btnTestOnly.disabled = true;
      btnNew.disabled = true;

      typebox.focus(); forceCaretToEnd();
      showToast("Warm-up started (1 minute).");
      rafId = requestAnimationFrame(tick);
    }

    function startStageBreak(){
      stopTicker();
      stage = STAGE_BREAK;
      stageDurationSec = BREAK_SEC;
      stageStartPerf = performance.now();

      typebox.disabled = true;
      showToast("Break started (30 seconds).");
      rafId = requestAnimationFrame(tick);
    }

    function startStageTest(fromCBTSTFlow){
      stopTicker();
      stage = STAGE_TEST;
      stageDurationSec = TEST_SEC;
      stageStartPerf = performance.now();

      renderPassage(generateMeaningfulPassage(350));
      resetCounters();

      typebox.disabled = false;
      btnReset.disabled = false;
      btnCBTST.disabled = true;
      btnTestOnly.disabled = true;
      btnNew.disabled = true;

      typebox.focus(); forceCaretToEnd();
      showToast(fromCBTSTFlow ? "Typing test started (10 minutes)." : "10-minute test started.");
      rafId = requestAnimationFrame(tick);
    }

    function tick(){
      const now = performance.now();
      const elapsed = (now - stageStartPerf) / 1000;
      const left = Math.max(0, stageDurationSec - elapsed);

      setTimerUI(left);
      setProgressUI(left);

      if (stage === STAGE_WARMUP){
        stageHint.textContent = "Warm-up: practice typing (not evaluated).";
        setState("Warm-up");
      } else if (stage === STAGE_BREAK){
        stageHint.textContent = "Break: relax your hands (typing disabled).";
        setState("Break");
      } else if (stage === STAGE_TEST){
        stageHint.textContent = "Test: 10 minutes (evaluated). Type continuously. No backspace.";
        setState("Running");

        const mins = Math.max(1/60, elapsed / 60);
        const totalWords = (typed.length / WORD_UNIT);
        const liveWpm = totalWords / mins;

        wordsTypedEl.textContent = totalWords.toFixed(2);
        rawWordsEl.textContent = String(tokenizeWords(typed).length);
        passageDoneEl.textContent = String(passageCompleted);
        liveWpmEl.textContent = liveWpm.toFixed(1);

        const acc = typed.length ? (correctChars / typed.length) * 100 : 100;
        accEl.textContent = `${acc.toFixed(2)}%`;

        // compute full/half + net occasionally (heavy DP), not on every frame
        if (!tick._lastHeavy || (now - tick._lastHeavy) > 2500){
          tick._lastHeavy = now;
          const m = computeFinalTestMetrics();
          fullMistEl.textContent = String(m.fullMistakes);
          halfMistEl.textContent = String(m.halfMistakes);
          allowErrEl.textContent = m.allowable.toFixed(2);
          finalMistEl.textContent = m.finalMist.toFixed(2);
          grossWpmEl.textContent = m.grossWpmExam.toFixed(1);
          netWpmEl.textContent = m.netWpm.toFixed(1);
        }
      }

      if (left <= 0.001){
        if (stage === STAGE_WARMUP){ startStageBreak(); return; }
        if (stage === STAGE_BREAK){ startStageTest(true); return; }
        if (stage === STAGE_TEST){ finishTest(); return; }
      }
      rafId = requestAnimationFrame(tick);
    }

    function stopTicker(){ cancelAnimationFrame(rafId); rafId = 0; }

    function openResults(m){
      const lines = [
        ["Status", m.status],
        ["Total characters typed", String(m.totalChars)],
        ["Total words (chars ÷ 5)", m.totalWords.toFixed(2)],
        ["Raw words (reference)", String(m.rawWords)],
        ["Passage completed", String(m.passagesCompleted)],
        ["Full mistakes", String(m.fullMistakes)],
        ["Half mistakes", String(m.halfMistakes)],
        ["Total mistakes (full + half/2)", m.totalMistakes.toFixed(2)],
        ["Allowable errors (5%)", m.allowable.toFixed(2)],
        ["Final mistakes", m.finalMist.toFixed(2)],
        ["Gross (10 min)", m.grossWpmExam.toFixed(2)],
        ["Net WPM", m.netWpm.toFixed(2)],
        ["Character accuracy", `${m.charAcc.toFixed(2)}%`]
      ];

      resultGrid.innerHTML = lines.map(([k,v]) =>
        `<div class="resultline"><span>${k}</span><strong>${v}</strong></div>`
      ).join("");

      modal.classList.add("show");
      modal.setAttribute("aria-hidden","false");
    }

    function closeResults(){
      modal.classList.remove("show");
      modal.setAttribute("aria-hidden","true");
    }

    function finishTest(){
      stopTicker();
      stage = STAGE_DONE;
      setState("Completed");
      typebox.disabled = true;

      const m = computeFinalTestMetrics();

      // set final UI
      wordsTypedEl.textContent = m.totalWords.toFixed(2);
      rawWordsEl.textContent = String(m.rawWords);
      passageDoneEl.textContent = String(m.passagesCompleted);
      fullMistEl.textContent = String(m.fullMistakes);
      halfMistEl.textContent = String(m.halfMistakes);
      allowErrEl.textContent = m.allowable.toFixed(2);
      finalMistEl.textContent = m.finalMist.toFixed(2);
      grossWpmEl.textContent = m.grossWpmExam.toFixed(1);
      netWpmEl.textContent = m.netWpm.toFixed(1);
      accEl.textContent = `${m.charAcc.toFixed(2)}%`;
      liveWpmEl.textContent = m.grossWpmExam.toFixed(1); // at 10 minutes, live avg = exam gross

      setTimerUI(0);
      setProgressUI(0);

      openResults(m);

      saveSession({
        ts: Date.now(),
        status: m.status,
        chars: m.totalChars,
        words: Number(m.totalWords.toFixed(2)),
        rawWords: m.rawWords,
        gross: Number(m.grossWpmExam.toFixed(2)),
        net: Number(m.netWpm.toFixed(2)),
        full: m.fullMistakes,
        half: m.halfMistakes,
        totalMist: Number(m.totalMistakes.toFixed(2)),
        allow: Number(m.allowable.toFixed(2)),
        finalMist: Number(m.finalMist.toFixed(2)),
        passDone: m.passagesCompleted,
        acc: Number(m.charAcc.toFixed(2))
      });

      renderHistory();

      btnReset.disabled = false;
      btnCBTST.disabled = false;
      btnTestOnly.disabled = false;
      btnNew.disabled = false;

      showToast("Test finished. Result saved.");
    }

    function hardReset(){
      stopTicker();
      stage = STAGE_IDLE;
      setState("Ready");
      stageHint.textContent = "Ready.";

      typebox.disabled = true;
      btnReset.disabled = true;
      btnCBTST.disabled = false;
      btnTestOnly.disabled = false;
      btnNew.disabled = false;

      renderPassage(generateMeaningfulPassage(350));
      resetCounters();

      setTimerUI(0);
      progEl.style.width = "0%";
      showToast("Reset done.");
    }

    function newPassage(){
      if (stage !== STAGE_IDLE){
        showToast("Reset first to change the passage.");
        return;
      }
      renderPassage(generateMeaningfulPassage(350));
      resetCounters();
      showToast("New passage generated.");
    }

    // -------------------------
    // Input restrictions + typing
    // -------------------------
    function onKeyDown(e){
      if (e.key === "Backspace" || e.key === "Delete"){
        e.preventDefault();
        showToast("Backspace/Delete is not allowed.");
        return;
      }
      if (stage !== STAGE_WARMUP && stage !== STAGE_TEST) return;

      const blocked = ["ArrowLeft","ArrowUp","ArrowRight","ArrowDown","Home","End","PageUp","PageDown"];
      if (blocked.includes(e.key)){
        e.preventDefault();
        showToast("Cursor movement is disabled.");
        forceCaretToEnd();
        return;
      }

      const ctrl = e.ctrlKey || e.metaKey;
      if (ctrl && ["a","x","v","z","y"].includes(e.key.toLowerCase())){
        e.preventDefault();
        showToast("Copy/Cut/Paste/Undo/Redo is disabled.");
        return;
      }
    }

    function onPaste(e){
      if (stage === STAGE_WARMUP || stage === STAGE_TEST){
        e.preventDefault();
        showToast("Paste is disabled.");
      }
    }
    function onDrop(e){
      if (stage === STAGE_WARMUP || stage === STAGE_TEST){
        e.preventDefault();
        showToast("Drop is disabled.");
      }
    }

    function onTypeInput(){
      if (stage !== STAGE_WARMUP && stage !== STAGE_TEST) return;

      const val = typebox.value;

      // no deletion allowed
      if (val.length < typed.length){
        typebox.value = typed;
        forceCaretToEnd();
        liveWarn.textContent = "Deletion is disabled.";
        return;
      }

      forceCaretToEnd();
      const added = val.slice(typed.length);
      if (!added) return;
      liveWarn.textContent = "";

      for (let i=0;i<added.length;i++){
        const ch = added[i];
        const pos = typed.length;
        typed += ch;

        if (!basePassageChars) continue;

        const loopPos = pos % basePassageChars;
        const expected = basePassageText[loopPos] ?? "";

        if (ch === expected){
          correctChars++;
          targetSpans[loopPos]?.classList.add("correct");
        } else {
          wrongChars++;
          targetSpans[loopPos]?.classList.add("incorrect");
        }

        const nextLoopPos = (loopPos + 1) % basePassageChars;
        setCursor(nextLoopPos);
        scrollCursorIntoView(nextLoopPos);

        // completed a full passage cycle exactly
        if ((loopPos + 1) === basePassageChars){
          passageCompleted++;
          passageDoneEl.textContent = String(passageCompleted);
          clearMarking();
          showToast("Passage completed. Retype from beginning.");
        }
      }

      // update light stats immediately
      const totalWords = typed.length / WORD_UNIT;
      wordsTypedEl.textContent = totalWords.toFixed(2);
      rawWordsEl.textContent = String(tokenizeWords(typed).length);

      const acc = typed.length ? (correctChars / typed.length) * 100 : 100;
      accEl.textContent = `${acc.toFixed(2)}%`;
    }

    // -------------------------
    // History (fast + pruned)
    // -------------------------
    function localDayKey(ts){
      const d = new Date(ts);
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,"0");
      const da = String(d.getDate()).padStart(2,"0");
      return `${y}-${m}-${da}`;
    }

    function cutoffTimestamp(){
      const now = new Date();
      const startToday = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const cut = new Date(startToday);
      cut.setDate(cut.getDate() - (KEEP_DAYS - 1));
      return cut.getTime();
    }

    function loadHistory(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return [];
        const arr = JSON.parse(raw);
        return Array.isArray(arr) ? arr : [];
      }catch{ return []; }
    }

    function saveHistory(arr){
      try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(arr)); }catch{}
    }

    function pruneHistory(arr){
      const cut = cutoffTimestamp();
      let out = arr.filter(x => x && typeof x.ts === "number" && x.ts >= cut);
      out.sort((a,b)=> b.ts - a.ts);
      if (out.length > MAX_SESSIONS) out = out.slice(0, MAX_SESSIONS);
      return out;
    }

    function saveSession(session){
      const hist = pruneHistory(loadHistory());
      hist.unshift(session);
      saveHistory(pruneHistory(hist));
    }

    function groupByDay(hist){
      const map = new Map();
      for (const s of hist){
        const key = localDayKey(s.ts);
        if (!map.has(key)) map.set(key, []);
        map.get(key).push(s);
      }
      return map;
    }

    function avg(nums){ return nums.length ? nums.reduce((a,b)=>a+b,0)/nums.length : 0; }

    function renderHistory(){
      const hist = pruneHistory(loadHistory());
      if (!hist.length){
        historyMini.textContent = "No tests saved yet.";
        historyTable.innerHTML = `<tr><td class="muted" colspan="5">No history yet.</td></tr>`;
        return;
      }

      const byDay = groupByDay(hist);
      const days = Array.from(byDay.keys()).sort((a,b) => (a < b ? 1 : -1));

      const daily = days.map(day => {
        const sessions = byDay.get(day);
        const nets = sessions.map(s => Number(s.net || 0));
        const best = Math.max(...nets);
        const avgNet = avg(nets);
        const bestIdx = nets.indexOf(best);
        const bestStatus = sessions[bestIdx]?.status || "—";
        return { day, count: sessions.length, best, avgNet, bestStatus };
      });

      historyTable.innerHTML = daily.map(d => `
        <tr>
          <td>${d.day}</td>
          <td class="muted">${d.count}</td>
          <td><strong>${d.best.toFixed(1)}</strong></td>
          <td class="muted">${d.avgNet.toFixed(1)}</td>
          <td class="muted">${d.bestStatus}</td>
        </tr>
      `).join("");

      const bestOverall = Math.max(...hist.map(s => Number(s.net||0)));
      historyMini.innerHTML =
        `Best net (saved): <strong>${bestOverall.toFixed(1)}</strong> • Tests saved: <strong>${hist.length}</strong> • Last: <strong>${new Date(hist[0].ts).toLocaleString()}</strong>`;
    }

    function exportCSV(){
      const hist = pruneHistory(loadHistory());
      if (!hist.length){ showToast("No history to export."); return; }

      const header = ["timestamp","date","status","chars","words_exam","words_raw","gross","net","full","half","totalMist","allow","finalMist","passDone","acc"];
      const lines = [header.join(",")];

      for (const s of hist.slice().reverse()){
        const row = [
          new Date(s.ts).toISOString(),
          localDayKey(s.ts),
          (s.status || "").replace(/,/g," "),
          s.chars ?? "",
          s.words ?? "",
          s.rawWords ?? "",
          s.gross ?? "",
          s.net ?? "",
          s.full ?? "",
          s.half ?? "",
          s.totalMist ?? "",
          s.allow ?? "",
          s.finalMist ?? "",
          s.passDone ?? "",
          s.acc ?? ""
        ];
        lines.push(row.join(","));
      }

      const blob = new Blob([lines.join("\n")], { type:"text/csv;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `indraveer-cbtst-history-${localDayKey(Date.now())}.csv`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function clearHistory(){
      try{ localStorage.removeItem(STORAGE_KEY); }catch{}
      renderHistory();
      showToast("History cleared.");
    }

    // -------------------------
    // Wire up
    // -------------------------
    btnNew.addEventListener("click", newPassage);
    btnCBTST.addEventListener("click", startStageWarmup);
    btnTestOnly.addEventListener("click", () => startStageTest(false));
    btnReset.addEventListener("click", hardReset);

    btnClose.addEventListener("click", closeResults);
    modal.addEventListener("click", (e) => { if (e.target === modal) closeResults(); });

    btnExport.addEventListener("click", exportCSV);
    btnClearHistory.addEventListener("click", clearHistory);

    typebox.addEventListener("input", onTypeInput);
    typebox.addEventListener("keydown", onKeyDown);
    typebox.addEventListener("paste", onPaste);
    typebox.addEventListener("drop", onDrop);
    typebox.addEventListener("contextmenu", (e) => { if (stage === STAGE_WARMUP || stage === STAGE_TEST) e.preventDefault(); });
    typebox.addEventListener("mouseup", () => { if (stage === STAGE_WARMUP || stage === STAGE_TEST) forceCaretToEnd(); });
    typebox.addEventListener("keyup", () => { if (stage === STAGE_WARMUP || stage === STAGE_TEST) forceCaretToEnd(); });
    typebox.addEventListener("focus", () => { if (stage === STAGE_WARMUP || stage === STAGE_TEST) forceCaretToEnd(); });

    // Init
    buildKeyboard();
    bankInfoEl.textContent = Array.isArray(window.WORDS) ? String(window.WORDS.length) : "fallback";
    hardReset();
    renderHistory();
  </script>
</body>
</html>
