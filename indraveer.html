<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Indraveer Typing Practice — Railway / SSC Style</title>
  <style>
    :root{
      --bg1:#0b1020;
      --bg2:#101a3a;
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.70);
      --muted2:rgba(255,255,255,.55);
      --good:#3ddc97;
      --bad:#ff5a7a;
      --warn:#ffd166;
      --stroke:rgba(255,255,255,.12);
      --stroke2:rgba(255,255,255,.18);
      --shadow: 0 18px 60px rgba(0,0,0,.40);
      --radius: 20px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; }
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 600px at 15% 10%, rgba(124, 92, 255, .30), transparent 60%),
        radial-gradient(900px 500px at 85% 20%, rgba(0, 212, 255, .20), transparent 55%),
        radial-gradient(800px 500px at 50% 90%, rgba(61, 220, 151, .16), transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
      overflow-x:hidden;
    }

    .app{ max-width: 1220px; margin: 0 auto; padding: 26px 16px 44px; }
    header{
      display:flex; align-items:center; justify-content:space-between; gap: 14px;
      margin-bottom: 14px;
    }

    .brand{ display:flex; align-items:center; gap: 12px; user-select:none; }
    .logo{
      width: 42px; height: 42px; border-radius: 14px;
      background: linear-gradient(135deg, rgba(124, 92, 255, .9), rgba(0, 212, 255, .6));
      box-shadow: 0 10px 30px rgba(124,92,255,.18);
      position: relative; overflow:hidden;
    }
    .logo:before{
      content:""; position:absolute; inset:-30%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.55), transparent 55%);
      transform: rotate(18deg);
    }

    h1{ font-size: 18px; line-height: 1.2; margin: 0; letter-spacing:.2px; }
    .subtitle{ margin: 3px 0 0; font-size: 12.5px; color: var(--muted); }

    .header-actions{ display:flex; align-items:center; gap: 10px; flex-wrap:wrap; justify-content:flex-end; }

    .btn{
      appearance:none;
      border: 1px solid var(--stroke);
      background: rgba(255,255,255,.05);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 14px;
      cursor:pointer;
      font-weight: 700;
      font-size: 13px;
      letter-spacing:.15px;
      box-shadow: 0 10px 26px rgba(0,0,0,.18);
      transition: transform .12s ease, border-color .12s ease, background .12s ease;
      white-space:nowrap;
    }
    .btn:hover{ transform: translateY(-1px); border-color: var(--stroke2); background: rgba(255,255,255,.07); }
    .btn:active{ transform: translateY(0px); }
    .btn.primary{ border-color: rgba(61,220,151,.35); background: rgba(61,220,151,.12); }
    .btn.warn{ border-color: rgba(255,209,102,.35); background: rgba(255,209,102,.10); }
    .btn.danger{ border-color: rgba(255,90,122,.38); background: rgba(255,90,122,.10); }
    .btn:disabled{ cursor:not-allowed; opacity:.55; transform:none; }

    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding: 8px 10px; border-radius: 999px;
      background: rgba(255,255,255,.05);
      border: 1px solid var(--stroke);
      color: var(--muted);
      font-size: 12.5px;
      user-select:none;
    }

    main{ display:grid; grid-template-columns: 320px 1fr 360px; gap: 14px; }
    @media (max-width: 1100px){ main{ grid-template-columns: 1fr; } }

    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.04));
      border: 1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }

    .card .card-h{
      display:flex; align-items:center; justify-content:space-between; gap: 10px;
      padding: 14px 16px;
      border-bottom: 1px solid var(--stroke);
      background: rgba(0,0,0,.12);
    }
    .card .card-h .title{
      margin:0; font-size: 13px; letter-spacing:.25px;
      color: rgba(255,255,255,.86);
      font-weight: 850; text-transform: uppercase;
    }
    .card .card-b{ padding: 14px 16px 16px; }

    .rule{ display:flex; gap: 10px; margin: 10px 0; color: var(--muted); font-size: 13px; line-height: 1.35; }
    .dot{ flex: 0 0 auto; width: 10px; height: 10px; border-radius: 50%; margin-top: 4px; background: rgba(255,255,255,.18); border: 1px solid rgba(255,255,255,.22); }
    .dot.good{ background: rgba(61,220,151,.22); border-color: rgba(61,220,151,.35); }
    .dot.bad{ background: rgba(255,90,122,.18); border-color: rgba(255,90,122,.35); }
    .dot.warn{ background: rgba(255,209,102,.18); border-color: rgba(255,209,102,.35); }

    .kbdgrid{ display:grid; grid-template-columns: repeat(10, minmax(0, 1fr)); gap: 6px; margin-top: 10px; }
    .key{
      font-family: var(--mono);
      font-size: 12.5px;
      padding: 7px 0;
      border-radius: 12px;
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.10);
      text-align:center;
      color: rgba(255,255,255,.82);
      user-select:none;
    }

    .progress{
      height: 10px; border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      overflow:hidden;
    }
    .progress > div{
      height:100%; width:0%;
      background: linear-gradient(90deg, rgba(124,92,255,.75), rgba(0,212,255,.65), rgba(61,220,151,.65));
      border-radius:999px;
      transition: width .18s ease;
    }

    .target{
      height: 260px;
      padding: 14px 16px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      overflow:auto;
      font-family: var(--mono);
      line-height: 1.65;
      font-size: 14px;
      letter-spacing: .15px;
      scroll-behavior:smooth;
    }

    .target .c{ white-space: pre-wrap; }
    .target .c.correct{ color: rgba(61,220,151,.92); }
    .target .c.incorrect{
      color: rgba(255,90,122,.95);
      text-decoration: underline;
      text-decoration-thickness: 2px;
      text-underline-offset: 3px;
    }
    .target .c.cursor{
      background: rgba(255,255,255,.16);
      border-radius: 3px;
      outline: 1px solid rgba(255,255,255,.18);
    }

    .typebox{
      width:100%;
      min-height: 170px;
      padding: 14px 16px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      color: var(--text);
      font-family: var(--mono);
      font-size: 15px;
      line-height: 1.55;
      resize: vertical;
      outline: none;
      box-shadow: 0 14px 40px rgba(0,0,0,.25);
    }
    .typebox:focus{ border-color: rgba(0,212,255,.35); }

    .hint{
      margin-top: 10px;
      display:flex; flex-wrap:wrap; gap: 8px;
      align-items:center; justify-content:space-between;
      color: var(--muted2);
      font-size: 12.5px;
      line-height: 1.25;
    }

    .toast{
      position: fixed; left: 50%; bottom: 16px;
      transform: translateX(-50%);
      background: rgba(0,0,0,.65);
      border: 1px solid rgba(255,255,255,.16);
      color: rgba(255,255,255,.92);
      padding: 10px 12px;
      border-radius: 999px;
      font-size: 13px;
      box-shadow: 0 14px 50px rgba(0,0,0,.45);
      opacity: 0; pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
      z-index: 999;
      max-width: min(92vw, 860px);
      text-align:center;
    }
    .toast.show{ opacity: 1; transform: translateX(-50%) translateY(-2px); }

    .statgrid{ display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .stat{
      padding: 12px 12px;
      border-radius: 16px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.14);
    }
    .stat .k{ font-size: 12px; color: var(--muted); letter-spacing:.2px; margin:0 0 6px; }
    .stat .v{ margin:0; font-size: 20px; font-weight: 900; letter-spacing:.2px; }
    .stat .sub{ margin-top: 6px; font-size: 12.2px; color: var(--muted2); line-height:1.25; }

    .big{ grid-column: 1 / -1; display:flex; align-items:flex-end; justify-content:space-between; gap: 10px; }
    .timer{ font-family: var(--mono); font-size: 28px; font-weight: 950; letter-spacing: .8px; margin:0; }
    .status{ display:flex; flex-wrap:wrap; gap: 8px; justify-content:flex-end; }

    .divider{ margin: 14px 0 0; padding-top: 14px; border-top: 1px solid rgba(255,255,255,.10); }

    .tablewrap{
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      background: rgba(0,0,0,.12);
      overflow:hidden;
    }
    table{ width:100%; border-collapse: collapse; font-size: 12.5px; }
    thead th{
      text-align:left; padding: 10px 10px;
      background: rgba(255,255,255,.04);
      border-bottom: 1px solid rgba(255,255,255,.10);
      color: rgba(255,255,255,.80);
      font-weight: 850;
      letter-spacing:.15px;
      white-space:nowrap;
    }
    tbody td{
      padding: 9px 10px;
      border-bottom: 1px solid rgba(255,255,255,.07);
      color: rgba(255,255,255,.86);
      white-space:nowrap;
    }
    tbody tr:last-child td{ border-bottom:none; }
    tbody td.muted{ color: var(--muted2); }
    .scroll{ max-height: 240px; overflow:auto; }

    .spark{
      display:flex; align-items:flex-end; gap: 6px; height: 60px;
      padding: 10px 10px 12px;
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      background: rgba(0,0,0,.12);
      margin-bottom: 10px;
      overflow:hidden;
    }
    .bar{
      width: 10px; border-radius: 999px;
      background: rgba(0, 212, 255, .35);
      outline: 1px solid rgba(255,255,255,.08);
      flex: 0 0 auto;
    }
    .bar.best{
      background: rgba(61, 220, 151, .38);
      outline-color: rgba(61, 220, 151, .22);
    }

    .modal{ position: fixed; inset: 0; display:none; place-items:center; background: rgba(0,0,0,.55); z-index: 1000; padding: 18px; }
    .modal.show{ display:grid; }
    .modal-card{
      width: min(860px, 100%);
      border-radius: 24px;
      border: 1px solid rgba(255,255,255,.14);
      background: linear-gradient(180deg, rgba(255,255,255,.08), rgba(255,255,255,.04));
      box-shadow: 0 30px 90px rgba(0,0,0,.55);
      overflow:hidden;
    }
    .modal-h{
      padding: 16px 18px;
      border-bottom: 1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.16);
      display:flex; align-items:center; justify-content:space-between; gap: 10px;
    }
    .modal-h h2{ margin:0; font-size: 16px; letter-spacing:.2px; }
    .modal-b{ padding: 16px 18px 18px; }
    .resultgrid{ display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .resultline{
      display:flex; justify-content:space-between; gap: 14px;
      padding: 10px 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.12);
      border-radius: 14px;
      color: var(--muted);
      font-size: 13.5px;
    }
    .resultline strong{ color: rgba(255,255,255,.92); }
    .note{ margin-top: 12px; color: var(--muted2); font-size: 12.5px; line-height: 1.35; }

    .sr-only{ position:absolute; width:1px; height:1px; padding:0; margin:-1px; overflow:hidden; clip:rect(0,0,0,0); white-space:nowrap; border:0; }
    code.k{ font-family: var(--mono); font-size: 12.5px; color: rgba(255,255,255,.84); }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1>Indraveer Typing Practice</h1>
          <p class="subtitle">Railway / SSC-style CBTST simulation • full/half mistakes • 5% allowable • retype passage</p>
        </div>
      </div>
      <div class="header-actions">
        <span class="pill" title="Backspace and Delete are disabled in warmup and test.">⌫ Backspace: <strong style="color:rgba(255,255,255,.92)">Not allowed</strong></span>
        <button id="btnNew" class="btn" type="button">New passage</button>
        <button id="btnCBTST" class="btn primary" type="button">Start CBTST</button>
        <button id="btnTestOnly" class="btn warn" type="button">Start 10-min only</button>
        <button id="btnReset" class="btn danger" type="button" disabled>Reset</button>
      </div>
    </header>

    <main>
      <!-- Left: Rules + scoring -->
      <section class="card">
        <div class="card-h">
          <p class="title">Railway / SSC rules & scoring</p>
        </div>
        <div class="card-b">
          <div class="rule"><span class="dot good"></span><span><strong>Stages:</strong> warm-up 1 minute, break 30 seconds, typing test 10 minutes.</span></div>
          <div class="rule"><span class="dot good"></span><span><strong>Retype:</strong> after finishing the passage, you can type the same passage again within 10 minutes (app repeats it automatically).</span></div>
          <div class="rule"><span class="dot warn"></span><span><strong>Minimum words:</strong> if total words typed in English is <strong>below 300</strong>, result is marked “not evaluated”.</span></div>
          <div class="rule"><span class="dot bad"></span><span><strong>Disqualify warning:</strong> if you do not complete the passage at least once in 10 minutes, result is marked “disqualified”.</span></div>

          <div style="margin-top:12px; color:rgba(255,255,255,.86); font-weight:850; letter-spacing:.2px;">Mistake calculation</div>
          <div class="rule"><span class="dot"></span><span><strong>Total mistakes</strong> = Full mistakes + (Half mistakes ÷ 2)</span></div>
          <div class="rule"><span class="dot"></span><span><strong>Allowable errors</strong> = 5% of total words typed</span></div>
          <div class="rule"><span class="dot"></span><span><strong>Final count of mistakes</strong> = max(0, Total mistakes − Allowable errors)</span></div>
          <div class="rule"><span class="dot"></span><span><strong>Net speed (WPM)</strong> = (Total words typed − (Final mistakes × 10)) ÷ 10</span></div>

          <div style="margin-top:10px; color:var(--muted2); font-size:12.5px; line-height:1.35;">
            In this app: <strong>half mistake</strong> means the typed word differs by only <strong>one character</strong> (or only case),
            otherwise it is a <strong>full mistake</strong>. The app uses word-alignment so one early mistake doesn’t wrongly ruin the whole line.
          </div>

          <div style="margin-top:14px; color:var(--muted); font-size:13px;">Characters used in the passage:</div>
          <div id="kbd" class="kbdgrid" aria-label="Character set"></div>
        </div>
      </section>

      <!-- Center: Target + typing -->
      <section class="card">
        <div class="card-h">
          <p class="title">Passage</p>
          <div style="display:flex; gap:10px; align-items:center; color:var(--muted); font-size:12.5px;">
            <span id="lenInfo">Words: —</span>
          </div>
        </div>
        <div class="card-b" style="display:flex; flex-direction:column; gap:12px;">
          <div class="progress" aria-label="time progress"><div id="prog"></div></div>
          <div id="target" class="target" aria-label="Target passage"></div>
          <div>
            <label class="sr-only" for="typebox">Typing input</label>
            <textarea id="typebox" class="typebox" placeholder="Press Start, then type here…" spellcheck="false" autocomplete="off" autocorrect="off" autocapitalize="off" disabled></textarea>
            <div class="hint">
              <span id="stageHint">Ready.</span>
              <span id="liveWarn" aria-live="polite"></span>
            </div>
          </div>
        </div>
      </section>

      <!-- Right: Stats + history -->
      <section class="card">
        <div class="card-h">
          <p class="title">Stats & history</p>
        </div>
        <div class="card-b">
          <div class="statgrid">
            <div class="stat big">
              <div>
                <p class="k">Timer</p>
                <p id="timer" class="timer">00:00</p>
              </div>
              <div class="status">
                <span id="statePill" class="pill">Status: <strong style="color:rgba(255,255,255,.92)">Ready</strong></span>
              </div>
            </div>

            <div class="stat">
              <p class="k">Total words typed</p>
              <p id="wordsTyped" class="v">0</p>
              <div class="sub">based on typed text</div>
            </div>

            <div class="stat">
              <p class="k">Passage completed</p>
              <p id="passageDone" class="v">0</p>
              <div class="sub">times completed in test</div>
            </div>

            <div class="stat">
              <p class="k">Full mistakes</p>
              <p id="fullMist" class="v">0</p>
              <div class="sub">wrong/missing/extra word</div>
            </div>

            <div class="stat">
              <p class="k">Half mistakes</p>
              <p id="halfMist" class="v">0</p>
              <div class="sub">one character difference</div>
            </div>

            <div class="stat">
              <p class="k">Allowable errors</p>
              <p id="allowErr" class="v">0</p>
              <div class="sub">5% of total words</div>
            </div>

            <div class="stat">
              <p class="k">Final mistakes</p>
              <p id="finalMist" class="v">0</p>
              <div class="sub">after 5% ignored</div>
            </div>

            <div class="stat">
              <p class="k">Gross speed</p>
              <p id="grossWpm" class="v">0</p>
              <div class="sub">total words ÷ 10</div>
            </div>

            <div class="stat">
              <p class="k">Net speed (WPM)</p>
              <p id="netWpm" class="v">0</p>
              <div class="sub">(words − final×10) ÷ 10</div>
            </div>

            <div class="stat">
              <p class="k">Character accuracy</p>
              <p id="acc" class="v">100%</p>
              <div class="sub">for practice feedback</div>
            </div>

            <div class="stat">
              <p class="k">Word bank loaded</p>
              <p id="bankInfo" class="v">—</p>
              <div class="sub">from words.html / words.js</div>
            </div>
          </div>

          <div class="divider">
            <div style="display:flex; align-items:flex-start; justify-content:space-between; gap: 10px; flex-wrap:wrap;">
              <div>
                <div style="color:rgba(255,255,255,.86); font-weight:900; letter-spacing:.15px; font-size:13px;">
                  Results history (last 20 days)
                </div>
                <div id="historyMini" style="margin-top:6px; color:var(--muted2); font-size:12.5px;">No tests saved yet.</div>
              </div>
              <div style="display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;">
                <button id="btnExport" class="btn" type="button">Export CSV</button>
                <button id="btnClearHistory" class="btn danger" type="button">Clear</button>
              </div>
            </div>

            <div id="spark" class="spark" aria-label="Daily best net speed chart"></div>

            <div class="tablewrap">
              <div class="scroll">
                <table>
                  <thead>
                    <tr>
                      <th>Date</th>
                      <th>Tests</th>
                      <th>Best Net</th>
                      <th>Avg Net</th>
                      <th>Best Status</th>
                    </tr>
                  </thead>
                  <tbody id="historyTable">
                    <tr><td class="muted" colspan="5">No history yet.</td></tr>
                  </tbody>
                </table>
              </div>
            </div>

            <div style="margin-top:10px; color:var(--muted2); font-size:12.5px; line-height:1.35;">
              Stored locally in your browser (localStorage). Auto-pruned to stay fast.
            </div>
          </div>
        </div>
      </section>
    </main>
  </div>

  <div id="toast" class="toast" role="status" aria-live="polite"></div>

  <div id="modal" class="modal" aria-hidden="true">
    <div class="modal-card" role="dialog" aria-modal="true" aria-labelledby="resultTitle">
      <div class="modal-h">
        <h2 id="resultTitle">Test result (10 minutes)</h2>
        <button id="btnClose" class="btn" type="button">Close</button>
      </div>
      <div class="modal-b">
        <div id="resultGrid" class="resultgrid"></div>
        <div class="note">
          Net WPM formula: <code class="k">(TotalWords − (FinalMistakes × 10)) ÷ 10</code>.
          Final mistakes are <code class="k">max(0, TotalMistakes − 0.05×TotalWords)</code>.
        </div>
      </div>
    </div>
  </div>

  <!-- Word bank: user asked for words.html; words.js is also supported if present -->
  <script src="words.js"></script>
  <script src="words.html"></script>

  <script>
    // -------------------------
    // Indraveer Typing Practice
    // Railway / SSC CBTST style
    // -------------------------

    // Stages
    const STAGE_IDLE   = "idle";
    const STAGE_WARMUP = "warmup";
    const STAGE_BREAK  = "break";
    const STAGE_TEST   = "test";
    const STAGE_DONE   = "done";

    const WARMUP_SEC = 60;
    const BREAK_SEC  = 30;
    const TEST_SEC   = 10 * 60;

    const MIN_WORDS_EN = 300;  // "not evaluated" threshold
    const KEEP_DAYS = 20;
    const MAX_SESSIONS = 200;
    const STORAGE_KEY = "indraveer_cbtst_history_v2";

    // Typical English punctuation set
    const PUNCT = [".", ",", ";", ":", "!", "?", "\"", "'", "-", "(", ")"];

    // Word bank from words file(s)
    const WORD_BANK = (Array.isArray(window.WORDS) && window.WORDS.length >= 1000)
      ? window.WORDS
      : ["the","and","to","of","in","a","is","that","for","it","practice","typing","speed","accuracy","exam","railway","candidate","result","mistake","final"];

    const $ = (id) => document.getElementById(id);

    // Buttons
    const btnNew = $("btnNew");
    const btnCBTST = $("btnCBTST");
    const btnTestOnly = $("btnTestOnly");
    const btnReset = $("btnReset");
    const btnClose = $("btnClose");
    const btnExport = $("btnExport");
    const btnClearHistory = $("btnClearHistory");

    // UI elements
    const targetEl = $("target");
    const typebox = $("typebox");
    const lenInfo = $("lenInfo");
    const stageHint = $("stageHint");
    const liveWarn = $("liveWarn");
    const progEl = $("prog");
    const timerEl = $("timer");
    const toastEl = $("toast");
    const modal = $("modal");
    const resultGrid = $("resultGrid");

    const statePill = $("statePill");
    const wordsTypedEl = $("wordsTyped");
    const passageDoneEl = $("passageDone");
    const fullMistEl = $("fullMist");
    const halfMistEl = $("halfMist");
    const allowErrEl = $("allowErr");
    const finalMistEl = $("finalMist");
    const grossWpmEl = $("grossWpm");
    const netWpmEl = $("netWpm");
    const accEl = $("acc");
    const bankInfoEl = $("bankInfo");

    const historyMini = $("historyMini");
    const historyTable = $("historyTable");
    const spark = $("spark");

    // Target render
    let targetText = "";
    let targetSpans = [];
    let basePassageText = "";
    let basePassageWords = [];
    let repeatsRendered = 1; // number of passages currently appended in targetText

    // Typing state
    let stage = STAGE_IDLE;
    let stageStartPerf = 0;
    let stageDurationSec = 0;
    let rafId = 0;

    let typed = "";
    let correctChars = 0;
    let wrongChars = 0;

    // Test-only metrics (computed at end using word alignment DP)
    let lastComputed = null;

    function clamp(n,a,b){ return Math.max(a, Math.min(b, n)); }
    function randInt(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }

    function showToast(msg){
      toastEl.textContent = msg;
      toastEl.classList.add("show");
      clearTimeout(showToast._t);
      showToast._t = setTimeout(() => toastEl.classList.remove("show"), 1000);
    }

    function setState(label){
      statePill.querySelector("strong").textContent = label;
    }

    function formatTime(sec){
      sec = Math.max(0, Math.ceil(sec));
      const m = Math.floor(sec/60);
      const s = sec % 60;
      return `${String(m).padStart(2,"0")}:${String(s).padStart(2,"0")}`;
    }

    function forceCaretToEnd(){
      const len = typebox.value.length;
      typebox.selectionStart = typebox.selectionEnd = len;
    }

    function buildKeyboard(){
      const chars = [];
      for (let c=65;c<=90;c++) chars.push(String.fromCharCode(c));
      for (let c=97;c<=122;c++) chars.push(String.fromCharCode(c));
      chars.push(" ");
      for (const p of PUNCT) chars.push(p);

      const kbd = $("kbd");
      kbd.innerHTML = "";
      for (const ch of chars){
        const d = document.createElement("div");
        d.className = "key";
        d.textContent = ch === " " ? "␠" : ch;
        d.title = ch === " " ? "Space" : ch;
        kbd.appendChild(d);
      }
    }

    function tokenizeWords(text){
      // "words" = sequences of non-whitespace
      const m = text.match(/\S+/g);
      return m ? m : [];
    }

    function randomWord(){
      return WORD_BANK[randInt(0, WORD_BANK.length-1)];
    }

    function generateMeaningfulPassage(targetWords = 340){
      // Creates exam-style English paragraphs using the word bank.
      // (One passage is fixed during the test and repeated on completion.)
      const connectors = ["however", "therefore", "because", "although", "while", "when", "where", "unless", "since", "after", "before"];
      const starters = ["Candidates", "The system", "This passage", "A student", "A worker", "The committee", "The officer", "The report", "A decision", "The process"];

      const words = [];
      while (words.length < targetWords){
        const sentenceLen = randInt(14, 22);
        const first = starters[randInt(0, starters.length-1)];
        const sentence = [first];

        for (let i=1;i<sentenceLen;i++){
          let w = randomWord();
          if (Math.random() < 0.10) w = connectors[randInt(0, connectors.length-1)];
          sentence.push(w);
        }

        // Capitalize proper sentence start
        sentence[0] = sentence[0][0].toUpperCase() + sentence[0].slice(1);

        // Insert mid punctuation
        if (Math.random() < 0.65){
          const k = randInt(3, sentence.length-4);
          const mid = [",",";",":"][randInt(0,2)];
          sentence[k] = sentence[k] + mid;
        }

        // End punctuation (mostly period)
        const r = Math.random();
        const end = r < 0.12 ? "?" : (r < 0.18 ? "!" : ".");
        let line = sentence.join(" ") + end;

        // Occasional quotes or parentheses
        if (Math.random() < 0.10) line = `"${line}"`;
        if (Math.random() < 0.08) line = `(${line})`;

        // Add to passage
        words.push(line);

        // Paragraph breaks
        if (Math.random() < 0.18) words.push("\n\n");
        else words.push(" ");
      }

      // Join, then trim whitespace nicely
      const raw = words.join("").replace(/\s+\n/g, "\n").replace(/\n\s+/g, "\n").trim();
      return raw;
    }

    function renderTarget(text){
      targetText = text;
      targetSpans = [];
      repeatsRendered = 1;

      const frag = document.createDocumentFragment();
      for (let i=0;i<targetText.length;i++){
        const s = document.createElement("span");
        s.className = "c";
        s.textContent = targetText[i];
        frag.appendChild(s);
        targetSpans.push(s);
      }
      targetEl.innerHTML = "";
      targetEl.appendChild(frag);

      const baseWordsCount = basePassageWords.length || tokenizeWords(basePassageText).length || 0;
      lenInfo.textContent = `Words: ${baseWordsCount.toLocaleString()} (passage)`;
      updateCursor(0);
      targetEl.scrollTop = 0;
    }

    function appendRetypeBlockIfNeeded(pos){
      // If user approaches end of currently rendered target, append another copy of base passage.
      // This simulates "retype the passage from beginning" inside time.
      const margin = 220; // chars
      if (pos < targetText.length - margin) return;

      const extra = "\n\n" + basePassageText;
      const frag = document.createDocumentFragment();
      for (let i=0;i<extra.length;i++){
        const s = document.createElement("span");
        s.className = "c";
        s.textContent = extra[i];
        frag.appendChild(s);
        targetSpans.push(s);
      }
      targetText += extra;
      targetEl.appendChild(frag);
      repeatsRendered += 1;

      showToast(`Passage completed — retype from beginning (repeat ${repeatsRendered}).`);
    }

    function updateCursor(pos){
      const old = targetEl.querySelector(".cursor");
      if (old) old.classList.remove("cursor");
      if (pos >= 0 && pos < targetSpans.length) targetSpans[pos].classList.add("cursor");
    }

    function scrollCursorIntoView(pos){
      const span = targetSpans[pos];
      if (!span) return;
      const container = targetEl;
      const top = span.offsetTop;
      const bottom = top + span.offsetHeight;
      const viewTop = container.scrollTop;
      const viewBottom = viewTop + container.clientHeight;

      if (top < viewTop + 18) container.scrollTop = Math.max(0, top - 24);
      else if (bottom > viewBottom - 18) container.scrollTop = bottom - container.clientHeight + 24;
    }

    function clearMarking(){
      for (const s of targetSpans){
        s.classList.remove("correct","incorrect");
      }
      updateCursor(0);
    }

    function resetCounters(){
      typed = "";
      correctChars = 0;
      wrongChars = 0;
      typebox.value = "";
      liveWarn.textContent = "";
      lastComputed = null;
      updateStatsUI({reset:true});
      clearMarking();
      targetEl.scrollTop = 0;
      forceCaretToEnd();
    }

    // --- Half-mistake check (one edit away) ---
    function isHalfMistakeWord(a, b){
      if (a === b) return false;
      if (!a || !b) return false;

      // case-only difference -> half mistake
      if (a.toLowerCase() === b.toLowerCase()) return true;

      const la = a.length, lb = b.length;
      if (Math.abs(la - lb) > 1) return false;

      // Equal length: allow 1 substitution
      if (la === lb){
        let diff = 0;
        for (let i=0;i<la;i++){
          if (a[i] !== b[i]){
            diff++;
            if (diff > 1) return false;
          }
        }
        return diff === 1;
      }

      // Length differs by 1: allow 1 insertion/deletion
      const shorter = la < lb ? a : b;
      const longer  = la < lb ? b : a;
      let i = 0, j = 0, edits = 0;
      while (i < shorter.length && j < longer.length){
        if (shorter[i] === longer[j]){
          i++; j++;
        } else {
          edits++;
          if (edits > 1) return false;
          j++; // skip one char in longer
        }
      }
      // remaining extra char in longer counts as 1 edit max
      return true;
    }

    // --- DP alignment to compute full/half mistakes robustly ---
    function computeMistakesWordAlignment(typedWords, expectedWords){
      const n = typedWords.length;
      const m = expectedWords.length;

      // dp rows (float costs), dir matrix (uint8) for backtracking
      // dir codes: 1=INS, 2=DEL, 3=MATCH, 4=HALF, 5=FULLSUB
      const dir = new Uint8Array((n+1)*(m+1));
      const prev = new Float32Array(m+1);
      const curr = new Float32Array(m+1);

      // init dp[0][j] = j (deleting expected words)
      prev[0] = 0;
      for (let j=1;j<=m;j++){
        prev[j] = prev[j-1] + 1;
        dir[0*(m+1)+j] = 2; // DEL
      }

      for (let i=1;i<=n;i++){
        curr[0] = prev[0] + 1;
        dir[i*(m+1)+0] = 1; // INS

        const tw = typedWords[i-1];
        for (let j=1;j<=m;j++){
          const ew = expectedWords[j-1];

          let subCost = 0;
          let subDir = 3; // MATCH
          if (tw === ew){
            subCost = 0; subDir = 3;
          } else if (isHalfMistakeWord(tw, ew)){
            subCost = 0.5; subDir = 4;
          } else {
            subCost = 1; subDir = 5;
          }

          const costIns = prev[j] + 1;         // dp[i-1][j] + 1
          const costDel = curr[j-1] + 1;       // dp[i][j-1] + 1
          const costSub = prev[j-1] + subCost; // dp[i-1][j-1] + sub

          // choose minimal (tie-break: prefer SUB, then DEL, then INS)
          let best = costSub;
          let bestDir = subDir;

          if (costDel < best - 1e-6 || (Math.abs(costDel-best) <= 1e-6 && bestDir !== 3 && bestDir !== 4 && bestDir !== 5)){
            best = costDel;
            bestDir = 2;
          }
          if (costIns < best - 1e-6){
            best = costIns;
            bestDir = 1;
          }

          curr[j] = best;
          dir[i*(m+1)+j] = bestDir;
        }

        // swap
        prev.set(curr);
      }

      // Choose best end j (no penalty for not typing remaining expected words)
      let bestJ = 0;
      let bestCost = prev[0];
      for (let j=1;j<=m;j++){
        if (prev[j] < bestCost){
          bestCost = prev[j];
          bestJ = j;
        }
      }

      // Backtrack from (n, bestJ)
      let i = n, j = bestJ;
      let full = 0, half = 0;
      while (i > 0 || j > 0){
        if (i === 0){
          // deletions
          full += j;
          break;
        }
        if (j === 0){
          // insertions
          full += i;
          break;
        }

        const code = dir[i*(m+1)+j];
        if (code === 1){
          // INS
          full++;
          i--;
        } else if (code === 2){
          // DEL
          full++;
          j--;
        } else if (code === 3){
          // MATCH
          i--; j--;
        } else if (code === 4){
          // HALF
          half++;
          i--; j--;
        } else if (code === 5){
          // FULL SUB
          full++;
          i--; j--;
        } else {
          // fallback
          i--; j--;
        }
      }

      return { fullMistakes: full, halfMistakes: half, alignedExpectedUsed: bestJ, totalCost: bestCost };
    }

    function computeFinalTestMetrics(){
      const typedWords = tokenizeWords(typed);

      // Expand expected words (repeat base passage) to cover typed length safely
      const baseLen = basePassageWords.length || 1;
      const needRepeats = Math.max(1, Math.ceil((typedWords.length + baseLen) / baseLen));
      const expectedWords = [];
      for (let r=0;r<needRepeats;r++){
        expectedWords.push(...basePassageWords);
      }

      const align = computeMistakesWordAlignment(typedWords, expectedWords);

      const totalWords = typedWords.length;
      const totalMistakes = align.fullMistakes + (align.halfMistakes / 2);
      const allowable = totalWords * 0.05;
      const finalMist = Math.max(0, totalMistakes - allowable);

      const grossWpm = totalWords / 10;
      const netWpm = Math.max(0, (totalWords - (finalMist * 10)) / 10);

      const charAcc = (typed.length > 0) ? (correctChars / typed.length) * 100 : 100;

      // Passage completion check: if we consumed >= baseLen expected words in alignment
      const passagesCompleted = Math.floor(align.alignedExpectedUsed / baseLen);

      let status = "Evaluated";
      if (totalWords < MIN_WORDS_EN) status = "Not evaluated (<300 words)";
      if (passagesCompleted < 1) status = "Disqualified (passage not completed)";

      return {
        status,
        totalWords,
        passagesCompleted,
        fullMistakes: align.fullMistakes,
        halfMistakes: align.halfMistakes,
        totalMistakes,
        allowable,
        finalMist,
        grossWpm,
        netWpm,
        charAcc
      };
    }

    function updateStatsUI(opts = {}){
      if (opts.reset){
        wordsTypedEl.textContent = "0";
        passageDoneEl.textContent = "0";
        fullMistEl.textContent = "0";
        halfMistEl.textContent = "0";
        allowErrEl.textContent = "0";
        finalMistEl.textContent = "0";
        grossWpmEl.textContent = "0";
        netWpmEl.textContent = "0";
        accEl.textContent = "100%";
        return;
      }

      // Lightweight live values
      const wordsNow = tokenizeWords(typed).length;
      wordsTypedEl.textContent = String(wordsNow);

      const acc = typed.length ? (correctChars / typed.length) * 100 : 100;
      accEl.textContent = `${acc.toFixed(2)}%`;

      // For live, compute full metrics only occasionally (to keep smooth)
      // We'll compute at most every ~700ms via tick()
    }

    function setTimerUI(secLeft){
      timerEl.textContent = formatTime(secLeft);
    }

    function setProgressUI(secLeft){
      if (stage === STAGE_WARMUP){
        const elapsed = Math.min(WARMUP_SEC, Math.max(0, stageDurationSec - secLeft));
        progEl.style.width = `${(elapsed / WARMUP_SEC) * 100}%`;
      } else if (stage === STAGE_BREAK){
        const elapsed = Math.min(BREAK_SEC, Math.max(0, stageDurationSec - secLeft));
        progEl.style.width = `${(elapsed / BREAK_SEC) * 100}%`;
      } else if (stage === STAGE_TEST){
        const elapsed = Math.min(TEST_SEC, Math.max(0, stageDurationSec - secLeft));
        progEl.style.width = `${(elapsed / TEST_SEC) * 100}%`;
      } else {
        progEl.style.width = "0%";
      }
    }

    function tick(){
      const now = performance.now();
      const elapsed = (now - stageStartPerf) / 1000;
      const left = Math.max(0, stageDurationSec - elapsed);

      setTimerUI(left);
      setProgressUI(left);

      // Update live metrics during warmup/test
      if (stage === STAGE_WARMUP){
        stageHint.textContent = "Warm-up: practice typing (not evaluated).";
        setState("Warm-up");
      } else if (stage === STAGE_BREAK){
        stageHint.textContent = "Break: relax your hands (typing disabled).";
        setState("Break");
      } else if (stage === STAGE_TEST){
        stageHint.textContent = "Test: 10 minutes (evaluated). Type continuously. No backspace.";
        setState("Running");

        // compute full metrics occasionally (cheap enough)
        if (!tick._last || (now - tick._last) > 700){
          tick._last = now;
          const m = computeFinalTestMetrics();
          passageDoneEl.textContent = String(m.passagesCompleted);
          fullMistEl.textContent = String(m.fullMistakes);
          halfMistEl.textContent = String(m.halfMistakes);
          allowErrEl.textContent = m.allowable.toFixed(2);
          finalMistEl.textContent = m.finalMist.toFixed(2);
          grossWpmEl.textContent = Math.floor(m.grossWpm + 1e-9).toString();
          netWpmEl.textContent = Math.floor(m.netWpm + 1e-9).toString();
          updateStatsUI();
        }
      }

      if (left <= 0.001){
        if (stage === STAGE_WARMUP){
          startStageBreak();
          return;
        } else if (stage === STAGE_BREAK){
          startStageTest(true);
          return;
        } else if (stage === STAGE_TEST){
          finishTest();
          return;
        }
      }

      rafId = requestAnimationFrame(tick);
    }

    function stopTicker(){
      cancelAnimationFrame(rafId);
      rafId = 0;
    }

    function startStageWarmup(){
      stopTicker();
      stage = STAGE_WARMUP;
      stageDurationSec = WARMUP_SEC;
      stageStartPerf = performance.now();

      // warmup passage: short + simple
      basePassageText = generateMeaningfulPassage(180);
      basePassageWords = tokenizeWords(basePassageText);

      renderTarget(basePassageText);
      resetCounters();

      typebox.disabled = false;
      btnReset.disabled = false;
      btnCBTST.disabled = true;
      btnTestOnly.disabled = true;
      btnNew.disabled = true;

      typebox.focus(); forceCaretToEnd();
      showToast("Warm-up started (1 minute).");
      rafId = requestAnimationFrame(tick);
    }

    function startStageBreak(){
      stopTicker();
      stage = STAGE_BREAK;
      stageDurationSec = BREAK_SEC;
      stageStartPerf = performance.now();

      typebox.disabled = true;
      showToast("Break started (30 seconds).");
      rafId = requestAnimationFrame(tick);
    }

    function startStageTest(fromCBTSTFlow){
      stopTicker();
      stage = STAGE_TEST;
      stageDurationSec = TEST_SEC;
      stageStartPerf = performance.now();

      // test passage: around 340+ words
      basePassageText = generateMeaningfulPassage(350);
      basePassageWords = tokenizeWords(basePassageText);

      // Render only one passage; repeats get appended automatically on completion
      renderTarget(basePassageText);

      // reset counters for evaluated test
      resetCounters();

      typebox.disabled = false;

      btnReset.disabled = false;
      btnCBTST.disabled = true;
      btnTestOnly.disabled = true;
      btnNew.disabled = true;

      typebox.focus(); forceCaretToEnd();
      showToast(fromCBTSTFlow ? "Typing test started (10 minutes)." : "10-minute test started.");
      rafId = requestAnimationFrame(tick);
    }

    function finishTest(){
      stopTicker();
      stage = STAGE_DONE;
      setState("Completed");
      typebox.disabled = true;

      const m = computeFinalTestMetrics();
      lastComputed = m;

      // Update right-side numbers with final
      wordsTypedEl.textContent = String(m.totalWords);
      passageDoneEl.textContent = String(m.passagesCompleted);
      fullMistEl.textContent = String(m.fullMistakes);
      halfMistEl.textContent = String(m.halfMistakes);
      allowErrEl.textContent = m.allowable.toFixed(2);
      finalMistEl.textContent = m.finalMist.toFixed(2);
      grossWpmEl.textContent = Math.floor(m.grossWpm + 1e-9).toString();
      netWpmEl.textContent = Math.floor(m.netWpm + 1e-9).toString();
      accEl.textContent = `${m.charAcc.toFixed(2)}%`;

      setTimerUI(0);
      setProgressUI(0);

      openResults(m);

      // Save result
      saveSession({
        ts: Date.now(),
        status: m.status,
        words: m.totalWords,
        net: Number(m.netWpm.toFixed(2)),
        gross: Number(m.grossWpm.toFixed(2)),
        full: m.fullMistakes,
        half: m.halfMistakes,
        totalMist: Number(m.totalMistakes.toFixed(2)),
        allow: Number(m.allowable.toFixed(2)),
        finalMist: Number(m.finalMist.toFixed(2)),
        passDone: m.passagesCompleted,
        acc: Number(m.charAcc.toFixed(2))
      });

      renderHistory();

      btnReset.disabled = false;
      btnCBTST.disabled = false;
      btnTestOnly.disabled = false;
      btnNew.disabled = false;

      showToast("Test finished. Result saved.");
    }

    function openResults(m){
      const lines = [
        ["Status", m.status],
        ["Total words typed", String(m.totalWords)],
        ["Passage completed", String(m.passagesCompleted)],
        ["Full mistakes", String(m.fullMistakes)],
        ["Half mistakes", String(m.halfMistakes)],
        ["Total mistakes (full + half/2)", m.totalMistakes.toFixed(2)],
        ["Allowable errors (5%)", m.allowable.toFixed(2)],
        ["Final count of mistakes", m.finalMist.toFixed(2)],
        ["Gross speed (WPM)", Math.floor(m.grossWpm + 1e-9).toString()],
        ["Net speed (WPM)", Math.floor(m.netWpm + 1e-9).toString()],
        ["Character accuracy", `${m.charAcc.toFixed(2)}%`]
      ];

      resultGrid.innerHTML = lines.map(([k,v]) =>
        `<div class="resultline"><span>${k}</span><strong>${v}</strong></div>`
      ).join("");

      modal.classList.add("show");
      modal.setAttribute("aria-hidden","false");
    }

    function closeResults(){
      modal.classList.remove("show");
      modal.setAttribute("aria-hidden","true");
    }

    function hardReset(){
      stopTicker();
      stage = STAGE_IDLE;
      setState("Ready");
      stageHint.textContent = "Ready.";

      typebox.disabled = true;
      btnReset.disabled = true;
      btnCBTST.disabled = false;
      btnTestOnly.disabled = false;
      btnNew.disabled = false;

      // generate a preview passage
      basePassageText = generateMeaningfulPassage(350);
      basePassageWords = tokenizeWords(basePassageText);
      renderTarget(basePassageText);

      resetCounters();
      setTimerUI(0);
      progEl.style.width = "0%";

      showToast("Reset done.");
    }

    function newPassage(){
      if (stage !== STAGE_IDLE){
        showToast("Reset first to change the passage.");
        return;
      }
      basePassageText = generateMeaningfulPassage(350);
      basePassageWords = tokenizeWords(basePassageText);
      renderTarget(basePassageText);
      resetCounters();
      showToast("New passage generated.");
    }

    // -------------------------
    // Input restrictions
    // -------------------------
    function onKeyDown(e){
      // Always block backspace/delete (warmup + test)
      if (e.key === "Backspace" || e.key === "Delete"){
        e.preventDefault();
        showToast("Backspace/Delete is not allowed.");
        return;
      }

      if (stage !== STAGE_WARMUP && stage !== STAGE_TEST) return;

      // Block cursor movement keys
      const blocked = ["ArrowLeft","ArrowUp","ArrowRight","ArrowDown","Home","End","PageUp","PageDown"];
      if (blocked.includes(e.key)){
        e.preventDefault();
        showToast("Cursor movement is disabled.");
        forceCaretToEnd();
        return;
      }

      // Block copy/cut/paste/undo/redo/select all
      const ctrl = e.ctrlKey || e.metaKey;
      if (ctrl && ["a","x","v","z","y"].includes(e.key.toLowerCase())){
        e.preventDefault();
        showToast("Copy/Cut/Paste/Undo/Redo is disabled.");
        return;
      }

      // Break stage: typing disabled anyway
    }

    function onPaste(e){
      if (stage === STAGE_WARMUP || stage === STAGE_TEST){
        e.preventDefault();
        showToast("Paste is disabled.");
      }
    }

    function onDrop(e){
      if (stage === STAGE_WARMUP || stage === STAGE_TEST){
        e.preventDefault();
        showToast("Drop is disabled.");
      }
    }

    function onTypeInput(){
      if (stage !== STAGE_WARMUP && stage !== STAGE_TEST) return;

      const val = typebox.value;

      // No deletion allowed: if user somehow deleted, restore
      if (val.length < typed.length){
        typebox.value = typed;
        forceCaretToEnd();
        liveWarn.textContent = "Deletion is disabled.";
        return;
      }

      forceCaretToEnd();
      const added = val.slice(typed.length);
      if (!added) return;

      liveWarn.textContent = "";

      for (let i=0;i<added.length;i++){
        const ch = added[i];
        const pos = typed.length;

        // If in test, auto-append another copy of the passage near end (retype rule)
        if (stage === STAGE_TEST){
          appendRetypeBlockIfNeeded(pos);
        }

        const expected = targetText[pos] ?? "";
        typed += ch;

        if (ch === expected){
          correctChars++;
          if (pos < targetSpans.length) targetSpans[pos].classList.add("correct");
        } else {
          wrongChars++;
          if (pos < targetSpans.length) targetSpans[pos].classList.add("incorrect");
        }

        updateCursor(pos + 1);
      }

      scrollCursorIntoView(typed.length);
      updateStatsUI();
    }

    // -------------------------
    // History (fast + pruned)
    // -------------------------
    function localDayKey(ts){
      const d = new Date(ts);
      const y = d.getFullYear();
      const m = String(d.getMonth()+1).padStart(2,"0");
      const da = String(d.getDate()).padStart(2,"0");
      return `${y}-${m}-${da}`;
    }

    function cutoffTimestamp(){
      const now = new Date();
      const startToday = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      const cut = new Date(startToday);
      cut.setDate(cut.getDate() - (KEEP_DAYS - 1));
      return cut.getTime();
    }

    function loadHistory(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return [];
        const arr = JSON.parse(raw);
        return Array.isArray(arr) ? arr : [];
      }catch{
        return [];
      }
    }

    function saveHistory(arr){
      try{
        localStorage.setItem(STORAGE_KEY, JSON.stringify(arr));
      }catch{
        // ignore
      }
    }

    function pruneHistory(arr){
      const cut = cutoffTimestamp();
      let out = arr.filter(x => x && typeof x.ts === "number" && x.ts >= cut);
      out.sort((a,b)=> b.ts - a.ts);
      if (out.length > MAX_SESSIONS) out = out.slice(0, MAX_SESSIONS);
      return out;
    }

    function saveSession(session){
      const hist = pruneHistory(loadHistory());
      hist.unshift(session);
      saveHistory(pruneHistory(hist));
    }

    function groupByDay(hist){
      const map = new Map();
      for (const s of hist){
        const key = localDayKey(s.ts);
        if (!map.has(key)) map.set(key, []);
        map.get(key).push(s);
      }
      return map;
    }

    function avg(nums){
      if (!nums.length) return 0;
      return nums.reduce((a,b)=>a+b,0) / nums.length;
    }

    function renderHistory(){
      const hist = pruneHistory(loadHistory());
      if (!hist.length){
        historyMini.textContent = "No tests saved yet.";
        historyTable.innerHTML = `<tr><td class="muted" colspan="5">No history yet.</td></tr>`;
        spark.innerHTML = "";
        return;
      }

      const byDay = groupByDay(hist);
      const days = Array.from(byDay.keys()).sort((a,b) => (a < b ? 1 : -1));
      const daily = days.map(day => {
        const sessions = byDay.get(day);
        const nets = sessions.map(s => Number(s.net || 0));
        const best = Math.max(...nets);
        const avgNet = avg(nets);
        const statuses = sessions.map(s => s.status || "");
        // "best status" = status of the session with best net
        const bestIdx = nets.indexOf(best);
        const bestStatus = statuses[bestIdx] || "—";
        return { day, count: sessions.length, best, avgNet, bestStatus };
      });

      historyTable.innerHTML = daily.map(d => `
        <tr>
          <td>${d.day}</td>
          <td class="muted">${d.count}</td>
          <td><strong>${Math.round(d.best)}</strong></td>
          <td class="muted">${d.avgNet.toFixed(1)}</td>
          <td class="muted">${d.bestStatus}</td>
        </tr>
      `).join("");

      const todayKey = localDayKey(Date.now());
      const todaySessions = byDay.get(todayKey) || [];
      const todayBest = todaySessions.length ? Math.max(...todaySessions.map(s => Number(s.net||0))) : 0;

      const last7 = daily.slice(0, 7);
      const last7Avg = last7.length ? avg(last7.map(d => d.avgNet)) : 0;
      const bestOverall = Math.max(...hist.map(s => Number(s.net||0)));

      historyMini.innerHTML =
        `Today best net: <strong>${Math.round(todayBest)}</strong> • ` +
        `7-day avg net: <strong>${last7Avg.toFixed(1)}</strong> • ` +
        `Best net (saved): <strong>${Math.round(bestOverall)}</strong> • ` +
        `Tests saved: <strong>${hist.length}</strong>`;

      // Spark bars
      const maxNet = Math.max(...daily.map(d => d.best), 1);
      spark.innerHTML = "";
      daily.slice().reverse().forEach((d) => {
        const h = Math.max(6, Math.round((d.best / maxNet) * 56));
        const div = document.createElement("div");
        div.className = "bar" + (d.day === todayKey ? " best" : "");
        div.style.height = `${h}px`;
        div.title = `${d.day} • best net ${Math.round(d.best)} • tests ${d.count}`;
        spark.appendChild(div);
      });
    }

    function exportCSV(){
      const hist = pruneHistory(loadHistory());
      if (!hist.length){
        showToast("No history to export.");
        return;
      }

      const header = ["timestamp","date","status","words","grossWpm","netWpm","full","half","totalMist","allowable","finalMist","passagesCompleted","charAcc"];
      const lines = [header.join(",")];

      for (const s of hist.slice().reverse()){
        const row = [
          new Date(s.ts).toISOString(),
          localDayKey(s.ts),
          (s.status || "").replace(/,/g," "),
          s.words ?? "",
          s.gross ?? "",
          s.net ?? "",
          s.full ?? "",
          s.half ?? "",
          s.totalMist ?? "",
          s.allow ?? "",
          s.finalMist ?? "",
          s.passDone ?? "",
          s.acc ?? ""
        ];
        lines.push(row.join(","));
      }

      const blob = new Blob([lines.join("\n")], { type:"text/csv;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `indraveer-cbtst-history-${localDayKey(Date.now())}.csv`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function clearHistory(){
      try{ localStorage.removeItem(STORAGE_KEY); }catch{}
      renderHistory();
      showToast("History cleared.");
    }

    // -------------------------
    // Wire up
    // -------------------------
    btnNew.addEventListener("click", newPassage);
    btnCBTST.addEventListener("click", startStageWarmup);
    btnTestOnly.addEventListener("click", () => startStageTest(false));
    btnReset.addEventListener("click", hardReset);

    btnClose.addEventListener("click", closeResults);
    modal.addEventListener("click", (e) => { if (e.target === modal) closeResults(); });

    btnExport.addEventListener("click", exportCSV);
    btnClearHistory.addEventListener("click", clearHistory);

    typebox.addEventListener("input", onTypeInput);
    typebox.addEventListener("keydown", onKeyDown);
    typebox.addEventListener("paste", onPaste);
    typebox.addEventListener("drop", onDrop);
    typebox.addEventListener("contextmenu", (e) => { if (stage === STAGE_WARMUP || stage === STAGE_TEST) e.preventDefault(); });
    typebox.addEventListener("mouseup", () => { if (stage === STAGE_WARMUP || stage === STAGE_TEST) forceCaretToEnd(); });
    typebox.addEventListener("keyup", () => { if (stage === STAGE_WARMUP || stage === STAGE_TEST) forceCaretToEnd(); });
    typebox.addEventListener("focus", () => { if (stage === STAGE_WARMUP || stage === STAGE_TEST) forceCaretToEnd(); });

    // Init
    buildKeyboard();
    bankInfoEl.textContent = Array.isArray(window.WORDS) ? String(window.WORDS.length) : "fallback";
    hardReset();
    renderHistory();
  </script>
</body>
</html>
